// Code generated from Sql.g4 by ANTLR 4.7.1. DO NOT EDIT.

package parser // Sql

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 220, 939,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 3, 2, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 3, 4, 3, 4, 3, 5, 3, 5,
	5, 5, 111, 10, 5, 3, 5, 3, 5, 3, 5, 7, 5, 116, 10, 5, 12, 5, 14, 5, 119,
	11, 5, 3, 6, 3, 6, 5, 6, 123, 10, 6, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 129,
	10, 7, 3, 8, 3, 8, 3, 8, 3, 8, 5, 8, 135, 10, 8, 3, 9, 3, 9, 3, 9, 3, 9,
	7, 9, 141, 10, 9, 12, 9, 14, 9, 144, 11, 9, 3, 9, 3, 9, 3, 10, 3, 10, 3,
	10, 3, 10, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 7, 11, 158, 10, 11,
	12, 11, 14, 11, 161, 11, 11, 5, 11, 163, 10, 11, 3, 11, 3, 11, 5, 11, 167,
	10, 11, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 175, 10, 12, 3,
	12, 3, 12, 3, 12, 3, 12, 5, 12, 181, 10, 12, 3, 12, 7, 12, 184, 10, 12,
	12, 12, 14, 12, 187, 11, 12, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13,
	3, 13, 7, 13, 196, 10, 13, 12, 13, 14, 13, 199, 11, 13, 3, 13, 3, 13, 3,
	13, 3, 13, 5, 13, 205, 10, 13, 3, 14, 3, 14, 5, 14, 209, 10, 14, 3, 14,
	3, 14, 5, 14, 213, 10, 14, 3, 15, 3, 15, 5, 15, 217, 10, 15, 3, 15, 3,
	15, 3, 15, 7, 15, 222, 10, 15, 12, 15, 14, 15, 225, 11, 15, 3, 15, 3, 15,
	3, 15, 3, 15, 7, 15, 231, 10, 15, 12, 15, 14, 15, 234, 11, 15, 5, 15, 236,
	10, 15, 3, 15, 3, 15, 5, 15, 240, 10, 15, 3, 15, 3, 15, 3, 15, 5, 15, 245,
	10, 15, 3, 15, 3, 15, 5, 15, 249, 10, 15, 3, 16, 5, 16, 252, 10, 16, 3,
	16, 3, 16, 3, 16, 7, 16, 257, 10, 16, 12, 16, 14, 16, 260, 11, 16, 3, 17,
	3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 7, 17, 268, 10, 17, 12, 17, 14, 17,
	271, 11, 17, 5, 17, 273, 10, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3,
	17, 7, 17, 281, 10, 17, 12, 17, 14, 17, 284, 11, 17, 5, 17, 286, 10, 17,
	3, 17, 5, 17, 289, 10, 17, 3, 18, 3, 18, 3, 18, 3, 18, 7, 18, 295, 10,
	18, 12, 18, 14, 18, 298, 11, 18, 5, 18, 300, 10, 18, 3, 18, 3, 18, 5, 18,
	304, 10, 18, 3, 19, 3, 19, 5, 19, 308, 10, 19, 3, 19, 3, 19, 3, 19, 3,
	19, 3, 19, 3, 20, 3, 20, 3, 21, 3, 21, 5, 21, 319, 10, 21, 3, 21, 5, 21,
	322, 10, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 5, 21, 329, 10, 21, 3,
	22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22,
	3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 348, 10, 22, 7, 22, 350,
	10, 22, 12, 22, 14, 22, 353, 11, 22, 3, 23, 5, 23, 356, 10, 23, 3, 23,
	3, 23, 5, 23, 360, 10, 23, 3, 23, 3, 23, 5, 23, 364, 10, 23, 3, 23, 3,
	23, 5, 23, 368, 10, 23, 5, 23, 370, 10, 23, 3, 24, 3, 24, 3, 24, 3, 24,
	3, 24, 3, 24, 3, 24, 7, 24, 379, 10, 24, 12, 24, 14, 24, 382, 11, 24, 3,
	24, 3, 24, 5, 24, 386, 10, 24, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25,
	3, 25, 5, 25, 395, 10, 25, 3, 26, 3, 26, 3, 27, 3, 27, 5, 27, 401, 10,
	27, 3, 27, 3, 27, 5, 27, 405, 10, 27, 5, 27, 407, 10, 27, 3, 28, 3, 28,
	3, 28, 3, 28, 7, 28, 413, 10, 28, 12, 28, 14, 28, 416, 11, 28, 3, 28, 3,
	28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29,
	7, 29, 430, 10, 29, 12, 29, 14, 29, 433, 11, 29, 3, 29, 3, 29, 3, 29, 5,
	29, 438, 10, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29,
	3, 29, 5, 29, 449, 10, 29, 3, 30, 3, 30, 3, 31, 3, 31, 3, 31, 3, 31, 5,
	31, 457, 10, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 7, 31, 465,
	10, 31, 12, 31, 14, 31, 468, 11, 31, 3, 32, 3, 32, 5, 32, 472, 10, 32,
	3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 5,
	33, 484, 10, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 492,
	10, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 7, 33, 499, 10, 33, 12, 33,
	14, 33, 502, 11, 33, 3, 33, 3, 33, 3, 33, 5, 33, 507, 10, 33, 3, 33, 3,
	33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 515, 10, 33, 3, 33, 3, 33, 3, 33,
	3, 33, 5, 33, 521, 10, 33, 3, 33, 3, 33, 5, 33, 525, 10, 33, 3, 33, 3,
	33, 3, 33, 5, 33, 530, 10, 33, 3, 33, 3, 33, 3, 33, 5, 33, 535, 10, 33,
	3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 541, 10, 34, 3, 34, 3, 34, 3, 34, 3,
	34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 7, 34, 552, 10, 34, 12, 34, 14,
	34, 555, 11, 34, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3,
	35, 3, 35, 3, 35, 3, 35, 3, 35, 6, 35, 580, 10, 35, 13, 35, 14, 35, 581,
	3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 7, 35, 591, 10, 35, 12,
	35, 14, 35, 594, 11, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	5, 35, 603, 10, 35, 3, 35, 5, 35, 606, 10, 35, 3, 35, 3, 35, 3, 35, 5,
	35, 611, 10, 35, 3, 35, 3, 35, 3, 35, 7, 35, 616, 10, 35, 12, 35, 14, 35,
	619, 11, 35, 5, 35, 621, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 7,
	35, 628, 10, 35, 12, 35, 14, 35, 631, 11, 35, 5, 35, 633, 10, 35, 3, 35,
	3, 35, 5, 35, 637, 10, 35, 3, 35, 5, 35, 640, 10, 35, 3, 35, 3, 35, 3,
	35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 7, 35, 650, 10, 35, 12, 35, 14,
	35, 653, 11, 35, 5, 35, 655, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 6,
	35, 672, 10, 35, 13, 35, 14, 35, 673, 3, 35, 3, 35, 5, 35, 678, 10, 35,
	3, 35, 3, 35, 3, 35, 3, 35, 6, 35, 684, 10, 35, 13, 35, 14, 35, 685, 3,
	35, 3, 35, 5, 35, 690, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3,
	35, 3, 35, 3, 35, 3, 35, 3, 35, 7, 35, 713, 10, 35, 12, 35, 14, 35, 716,
	11, 35, 5, 35, 718, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3,
	35, 5, 35, 727, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35, 5, 35, 733, 10, 35,
	3, 35, 3, 35, 3, 35, 3, 35, 5, 35, 739, 10, 35, 3, 35, 3, 35, 3, 35, 3,
	35, 5, 35, 745, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	5, 35, 754, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3,
	35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	7, 35, 774, 10, 35, 12, 35, 14, 35, 777, 11, 35, 5, 35, 779, 10, 35, 3,
	35, 5, 35, 782, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	3, 35, 7, 35, 792, 10, 35, 12, 35, 14, 35, 795, 11, 35, 3, 36, 3, 36, 3,
	36, 3, 36, 5, 36, 801, 10, 36, 5, 36, 803, 10, 36, 3, 37, 3, 37, 3, 38,
	3, 38, 3, 39, 3, 39, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3,
	40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40,
	3, 40, 3, 40, 3, 40, 7, 40, 832, 10, 40, 12, 40, 14, 40, 835, 11, 40, 3,
	40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 7, 40, 844, 10, 40, 12, 40,
	14, 40, 847, 11, 40, 3, 40, 3, 40, 5, 40, 851, 10, 40, 5, 40, 853, 10,
	40, 3, 40, 3, 40, 7, 40, 857, 10, 40, 12, 40, 14, 40, 860, 11, 40, 3, 41,
	3, 41, 5, 41, 864, 10, 41, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 870, 10,
	42, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44,
	3, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 7, 45, 890, 10,
	45, 12, 45, 14, 45, 893, 11, 45, 5, 45, 895, 10, 45, 3, 45, 3, 45, 3, 45,
	3, 45, 3, 45, 7, 45, 902, 10, 45, 12, 45, 14, 45, 905, 11, 45, 5, 45, 907,
	10, 45, 3, 45, 3, 45, 3, 46, 3, 46, 3, 46, 3, 46, 5, 46, 915, 10, 46, 3,
	47, 3, 47, 3, 47, 7, 47, 920, 10, 47, 12, 47, 14, 47, 923, 11, 47, 3, 48,
	3, 48, 3, 48, 3, 48, 3, 48, 5, 48, 930, 10, 48, 3, 49, 3, 49, 3, 49, 5,
	49, 935, 10, 49, 3, 50, 3, 50, 3, 50, 2, 8, 22, 42, 60, 66, 68, 78, 51,
	2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,
	40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
	76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 2, 15, 4, 2, 57, 57, 80,
	80, 4, 2, 12, 12, 206, 206, 4, 2, 56, 56, 176, 176, 4, 2, 19, 19, 48, 48,
	4, 2, 64, 64, 91, 91, 4, 2, 12, 12, 50, 50, 4, 2, 21, 21, 159, 159, 3,
	2, 197, 198, 3, 2, 199, 201, 3, 2, 191, 196, 5, 2, 12, 12, 16, 16, 155,
	155, 4, 2, 62, 62, 170, 170, 45, 2, 11, 12, 14, 14, 16, 17, 19, 21, 24,
	25, 28, 34, 39, 39, 43, 45, 48, 48, 51, 51, 57, 57, 60, 60, 63, 65, 67,
	67, 70, 73, 77, 78, 80, 80, 82, 82, 84, 84, 86, 86, 89, 89, 91, 92, 94,
	94, 96, 96, 99, 102, 104, 108, 112, 113, 115, 116, 119, 119, 121, 126,
	128, 132, 134, 139, 141, 141, 143, 147, 149, 159, 161, 163, 165, 169, 171,
	172, 174, 175, 178, 178, 180, 180, 182, 183, 187, 190, 2, 1063, 2, 100,
	3, 2, 2, 2, 4, 103, 3, 2, 2, 2, 6, 106, 3, 2, 2, 2, 8, 108, 3, 2, 2, 2,
	10, 122, 3, 2, 2, 2, 12, 124, 3, 2, 2, 2, 14, 130, 3, 2, 2, 2, 16, 136,
	3, 2, 2, 2, 18, 147, 3, 2, 2, 2, 20, 151, 3, 2, 2, 2, 22, 168, 3, 2, 2,
	2, 24, 204, 3, 2, 2, 2, 26, 206, 3, 2, 2, 2, 28, 214, 3, 2, 2, 2, 30, 251,
	3, 2, 2, 2, 32, 288, 3, 2, 2, 2, 34, 303, 3, 2, 2, 2, 36, 305, 3, 2, 2,
	2, 38, 314, 3, 2, 2, 2, 40, 328, 3, 2, 2, 2, 42, 330, 3, 2, 2, 2, 44, 369,
	3, 2, 2, 2, 46, 385, 3, 2, 2, 2, 48, 387, 3, 2, 2, 2, 50, 396, 3, 2, 2,
	2, 52, 398, 3, 2, 2, 2, 54, 408, 3, 2, 2, 2, 56, 448, 3, 2, 2, 2, 58, 450,
	3, 2, 2, 2, 60, 456, 3, 2, 2, 2, 62, 469, 3, 2, 2, 2, 64, 534, 3, 2, 2,
	2, 66, 540, 3, 2, 2, 2, 68, 781, 3, 2, 2, 2, 70, 802, 3, 2, 2, 2, 72, 804,
	3, 2, 2, 2, 74, 806, 3, 2, 2, 2, 76, 808, 3, 2, 2, 2, 78, 852, 3, 2, 2,
	2, 80, 863, 3, 2, 2, 2, 82, 869, 3, 2, 2, 2, 84, 871, 3, 2, 2, 2, 86, 876,
	3, 2, 2, 2, 88, 882, 3, 2, 2, 2, 90, 914, 3, 2, 2, 2, 92, 916, 3, 2, 2,
	2, 94, 929, 3, 2, 2, 2, 96, 934, 3, 2, 2, 2, 98, 936, 3, 2, 2, 2, 100,
	101, 5, 6, 4, 2, 101, 102, 7, 2, 2, 3, 102, 3, 3, 2, 2, 2, 103, 104, 5,
	58, 30, 2, 104, 105, 7, 2, 2, 3, 105, 5, 3, 2, 2, 2, 106, 107, 5, 20, 11,
	2, 107, 7, 3, 2, 2, 2, 108, 110, 7, 186, 2, 2, 109, 111, 7, 133, 2, 2,
	110, 109, 3, 2, 2, 2, 110, 111, 3, 2, 2, 2, 111, 112, 3, 2, 2, 2, 112,
	117, 5, 36, 19, 2, 113, 114, 7, 3, 2, 2, 114, 116, 5, 36, 19, 2, 115, 113,
	3, 2, 2, 2, 116, 119, 3, 2, 2, 2, 117, 115, 3, 2, 2, 2, 117, 118, 3, 2,
	2, 2, 118, 9, 3, 2, 2, 2, 119, 117, 3, 2, 2, 2, 120, 123, 5, 12, 7, 2,
	121, 123, 5, 14, 8, 2, 122, 120, 3, 2, 2, 2, 122, 121, 3, 2, 2, 2, 123,
	11, 3, 2, 2, 2, 124, 125, 5, 94, 48, 2, 125, 128, 5, 78, 40, 2, 126, 127,
	7, 32, 2, 2, 127, 129, 5, 70, 36, 2, 128, 126, 3, 2, 2, 2, 128, 129, 3,
	2, 2, 2, 129, 13, 3, 2, 2, 2, 130, 131, 7, 95, 2, 2, 131, 134, 5, 92, 47,
	2, 132, 133, 9, 2, 2, 2, 133, 135, 7, 129, 2, 2, 134, 132, 3, 2, 2, 2,
	134, 135, 3, 2, 2, 2, 135, 15, 3, 2, 2, 2, 136, 137, 7, 4, 2, 2, 137, 142,
	5, 18, 10, 2, 138, 139, 7, 3, 2, 2, 139, 141, 5, 18, 10, 2, 140, 138, 3,
	2, 2, 2, 141, 144, 3, 2, 2, 2, 142, 140, 3, 2, 2, 2, 142, 143, 3, 2, 2,
	2, 143, 145, 3, 2, 2, 2, 144, 142, 3, 2, 2, 2, 145, 146, 7, 5, 2, 2, 146,
	17, 3, 2, 2, 2, 147, 148, 5, 94, 48, 2, 148, 149, 7, 191, 2, 2, 149, 150,
	5, 58, 30, 2, 150, 19, 3, 2, 2, 2, 151, 162, 5, 22, 12, 2, 152, 153, 7,
	118, 2, 2, 153, 154, 7, 23, 2, 2, 154, 159, 5, 26, 14, 2, 155, 156, 7,
	3, 2, 2, 156, 158, 5, 26, 14, 2, 157, 155, 3, 2, 2, 2, 158, 161, 3, 2,
	2, 2, 159, 157, 3, 2, 2, 2, 159, 160, 3, 2, 2, 2, 160, 163, 3, 2, 2, 2,
	161, 159, 3, 2, 2, 2, 162, 152, 3, 2, 2, 2, 162, 163, 3, 2, 2, 2, 163,
	166, 3, 2, 2, 2, 164, 165, 7, 96, 2, 2, 165, 167, 9, 3, 2, 2, 166, 164,
	3, 2, 2, 2, 166, 167, 3, 2, 2, 2, 167, 21, 3, 2, 2, 2, 168, 169, 8, 12,
	1, 2, 169, 170, 5, 24, 13, 2, 170, 185, 3, 2, 2, 2, 171, 172, 12, 4, 2,
	2, 172, 174, 7, 85, 2, 2, 173, 175, 5, 38, 20, 2, 174, 173, 3, 2, 2, 2,
	174, 175, 3, 2, 2, 2, 175, 176, 3, 2, 2, 2, 176, 184, 5, 22, 12, 5, 177,
	178, 12, 3, 2, 2, 178, 180, 9, 4, 2, 2, 179, 181, 5, 38, 20, 2, 180, 179,
	3, 2, 2, 2, 180, 181, 3, 2, 2, 2, 181, 182, 3, 2, 2, 2, 182, 184, 5, 22,
	12, 4, 183, 171, 3, 2, 2, 2, 183, 177, 3, 2, 2, 2, 184, 187, 3, 2, 2, 2,
	185, 183, 3, 2, 2, 2, 185, 186, 3, 2, 2, 2, 186, 23, 3, 2, 2, 2, 187, 185,
	3, 2, 2, 2, 188, 205, 5, 28, 15, 2, 189, 190, 7, 160, 2, 2, 190, 205, 5,
	92, 47, 2, 191, 192, 7, 181, 2, 2, 192, 197, 5, 58, 30, 2, 193, 194, 7,
	3, 2, 2, 194, 196, 5, 58, 30, 2, 195, 193, 3, 2, 2, 2, 196, 199, 3, 2,
	2, 2, 197, 195, 3, 2, 2, 2, 197, 198, 3, 2, 2, 2, 198, 205, 3, 2, 2, 2,
	199, 197, 3, 2, 2, 2, 200, 201, 7, 4, 2, 2, 201, 202, 5, 20, 11, 2, 202,
	203, 7, 5, 2, 2, 203, 205, 3, 2, 2, 2, 204, 188, 3, 2, 2, 2, 204, 189,
	3, 2, 2, 2, 204, 191, 3, 2, 2, 2, 204, 200, 3, 2, 2, 2, 205, 25, 3, 2,
	2, 2, 206, 208, 5, 58, 30, 2, 207, 209, 9, 5, 2, 2, 208, 207, 3, 2, 2,
	2, 208, 209, 3, 2, 2, 2, 209, 212, 3, 2, 2, 2, 210, 211, 7, 113, 2, 2,
	211, 213, 9, 6, 2, 2, 212, 210, 3, 2, 2, 2, 212, 213, 3, 2, 2, 2, 213,
	27, 3, 2, 2, 2, 214, 216, 7, 148, 2, 2, 215, 217, 5, 38, 20, 2, 216, 215,
	3, 2, 2, 2, 216, 217, 3, 2, 2, 2, 217, 218, 3, 2, 2, 2, 218, 223, 5, 40,
	21, 2, 219, 220, 7, 3, 2, 2, 220, 222, 5, 40, 21, 2, 221, 219, 3, 2, 2,
	2, 222, 225, 3, 2, 2, 2, 223, 221, 3, 2, 2, 2, 223, 224, 3, 2, 2, 2, 224,
	235, 3, 2, 2, 2, 225, 223, 3, 2, 2, 2, 226, 227, 7, 68, 2, 2, 227, 232,
	5, 42, 22, 2, 228, 229, 7, 3, 2, 2, 229, 231, 5, 42, 22, 2, 230, 228, 3,
	2, 2, 2, 231, 234, 3, 2, 2, 2, 232, 230, 3, 2, 2, 2, 232, 233, 3, 2, 2,
	2, 233, 236, 3, 2, 2, 2, 234, 232, 3, 2, 2, 2, 235, 226, 3, 2, 2, 2, 235,
	236, 3, 2, 2, 2, 236, 239, 3, 2, 2, 2, 237, 238, 7, 185, 2, 2, 238, 240,
	5, 60, 31, 2, 239, 237, 3, 2, 2, 2, 239, 240, 3, 2, 2, 2, 240, 244, 3,
	2, 2, 2, 241, 242, 7, 74, 2, 2, 242, 243, 7, 23, 2, 2, 243, 245, 5, 30,
	16, 2, 244, 241, 3, 2, 2, 2, 244, 245, 3, 2, 2, 2, 245, 248, 3, 2, 2, 2,
	246, 247, 7, 76, 2, 2, 247, 249, 5, 60, 31, 2, 248, 246, 3, 2, 2, 2, 248,
	249, 3, 2, 2, 2, 249, 29, 3, 2, 2, 2, 250, 252, 5, 38, 20, 2, 251, 250,
	3, 2, 2, 2, 251, 252, 3, 2, 2, 2, 252, 253, 3, 2, 2, 2, 253, 258, 5, 32,
	17, 2, 254, 255, 7, 3, 2, 2, 255, 257, 5, 32, 17, 2, 256, 254, 3, 2, 2,
	2, 257, 260, 3, 2, 2, 2, 258, 256, 3, 2, 2, 2, 258, 259, 3, 2, 2, 2, 259,
	31, 3, 2, 2, 2, 260, 258, 3, 2, 2, 2, 261, 289, 5, 34, 18, 2, 262, 263,
	7, 142, 2, 2, 263, 272, 7, 4, 2, 2, 264, 269, 5, 92, 47, 2, 265, 266, 7,
	3, 2, 2, 266, 268, 5, 92, 47, 2, 267, 265, 3, 2, 2, 2, 268, 271, 3, 2,
	2, 2, 269, 267, 3, 2, 2, 2, 269, 270, 3, 2, 2, 2, 270, 273, 3, 2, 2, 2,
	271, 269, 3, 2, 2, 2, 272, 264, 3, 2, 2, 2, 272, 273, 3, 2, 2, 2, 273,
	274, 3, 2, 2, 2, 274, 289, 7, 5, 2, 2, 275, 276, 7, 38, 2, 2, 276, 285,
	7, 4, 2, 2, 277, 282, 5, 92, 47, 2, 278, 279, 7, 3, 2, 2, 279, 281, 5,
	92, 47, 2, 280, 278, 3, 2, 2, 2, 281, 284, 3, 2, 2, 2, 282, 280, 3, 2,
	2, 2, 282, 283, 3, 2, 2, 2, 283, 286, 3, 2, 2, 2, 284, 282, 3, 2, 2, 2,
	285, 277, 3, 2, 2, 2, 285, 286, 3, 2, 2, 2, 286, 287, 3, 2, 2, 2, 287,
	289, 7, 5, 2, 2, 288, 261, 3, 2, 2, 2, 288, 262, 3, 2, 2, 2, 288, 275,
	3, 2, 2, 2, 289, 33, 3, 2, 2, 2, 290, 299, 7, 4, 2, 2, 291, 296, 5, 58,
	30, 2, 292, 293, 7, 3, 2, 2, 293, 295, 5, 58, 30, 2, 294, 292, 3, 2, 2,
	2, 295, 298, 3, 2, 2, 2, 296, 294, 3, 2, 2, 2, 296, 297, 3, 2, 2, 2, 297,
	300, 3, 2, 2, 2, 298, 296, 3, 2, 2, 2, 299, 291, 3, 2, 2, 2, 299, 300,
	3, 2, 2, 2, 300, 301, 3, 2, 2, 2, 301, 304, 7, 5, 2, 2, 302, 304, 5, 58,
	30, 2, 303, 290, 3, 2, 2, 2, 303, 302, 3, 2, 2, 2, 304, 35, 3, 2, 2, 2,
	305, 307, 5, 94, 48, 2, 306, 308, 5, 54, 28, 2, 307, 306, 3, 2, 2, 2, 307,
	308, 3, 2, 2, 2, 308, 309, 3, 2, 2, 2, 309, 310, 7, 18, 2, 2, 310, 311,
	7, 4, 2, 2, 311, 312, 5, 20, 11, 2, 312, 313, 7, 5, 2, 2, 313, 37, 3, 2,
	2, 2, 314, 315, 9, 7, 2, 2, 315, 39, 3, 2, 2, 2, 316, 321, 5, 58, 30, 2,
	317, 319, 7, 18, 2, 2, 318, 317, 3, 2, 2, 2, 318, 319, 3, 2, 2, 2, 319,
	320, 3, 2, 2, 2, 320, 322, 5, 94, 48, 2, 321, 318, 3, 2, 2, 2, 321, 322,
	3, 2, 2, 2, 322, 329, 3, 2, 2, 2, 323, 324, 5, 92, 47, 2, 324, 325, 7,
	6, 2, 2, 325, 326, 7, 199, 2, 2, 326, 329, 3, 2, 2, 2, 327, 329, 7, 199,
	2, 2, 328, 316, 3, 2, 2, 2, 328, 323, 3, 2, 2, 2, 328, 327, 3, 2, 2, 2,
	329, 41, 3, 2, 2, 2, 330, 331, 8, 22, 1, 2, 331, 332, 5, 48, 25, 2, 332,
	351, 3, 2, 2, 2, 333, 347, 12, 4, 2, 2, 334, 335, 7, 37, 2, 2, 335, 336,
	7, 90, 2, 2, 336, 348, 5, 48, 25, 2, 337, 338, 5, 44, 23, 2, 338, 339,
	7, 90, 2, 2, 339, 340, 5, 42, 22, 2, 340, 341, 5, 46, 24, 2, 341, 348,
	3, 2, 2, 2, 342, 343, 7, 103, 2, 2, 343, 344, 5, 44, 23, 2, 344, 345, 7,
	90, 2, 2, 345, 346, 5, 48, 25, 2, 346, 348, 3, 2, 2, 2, 347, 334, 3, 2,
	2, 2, 347, 337, 3, 2, 2, 2, 347, 342, 3, 2, 2, 2, 348, 350, 3, 2, 2, 2,
	349, 333, 3, 2, 2, 2, 350, 353, 3, 2, 2, 2, 351, 349, 3, 2, 2, 2, 351,
	352, 3, 2, 2, 2, 352, 43, 3, 2, 2, 2, 353, 351, 3, 2, 2, 2, 354, 356, 7,
	81, 2, 2, 355, 354, 3, 2, 2, 2, 355, 356, 3, 2, 2, 2, 356, 370, 3, 2, 2,
	2, 357, 359, 7, 93, 2, 2, 358, 360, 7, 120, 2, 2, 359, 358, 3, 2, 2, 2,
	359, 360, 3, 2, 2, 2, 360, 370, 3, 2, 2, 2, 361, 363, 7, 140, 2, 2, 362,
	364, 7, 120, 2, 2, 363, 362, 3, 2, 2, 2, 363, 364, 3, 2, 2, 2, 364, 370,
	3, 2, 2, 2, 365, 367, 7, 69, 2, 2, 366, 368, 7, 120, 2, 2, 367, 366, 3,
	2, 2, 2, 367, 368, 3, 2, 2, 2, 368, 370, 3, 2, 2, 2, 369, 355, 3, 2, 2,
	2, 369, 357, 3, 2, 2, 2, 369, 361, 3, 2, 2, 2, 369, 365, 3, 2, 2, 2, 370,
	45, 3, 2, 2, 2, 371, 372, 7, 114, 2, 2, 372, 386, 5, 60, 31, 2, 373, 374,
	7, 179, 2, 2, 374, 375, 7, 4, 2, 2, 375, 380, 5, 94, 48, 2, 376, 377, 7,
	3, 2, 2, 377, 379, 5, 94, 48, 2, 378, 376, 3, 2, 2, 2, 379, 382, 3, 2,
	2, 2, 380, 378, 3, 2, 2, 2, 380, 381, 3, 2, 2, 2, 381, 383, 3, 2, 2, 2,
	382, 380, 3, 2, 2, 2, 383, 384, 7, 5, 2, 2, 384, 386, 3, 2, 2, 2, 385,
	371, 3, 2, 2, 2, 385, 373, 3, 2, 2, 2, 386, 47, 3, 2, 2, 2, 387, 394, 5,
	52, 27, 2, 388, 389, 7, 162, 2, 2, 389, 390, 5, 50, 26, 2, 390, 391, 7,
	4, 2, 2, 391, 392, 5, 58, 30, 2, 392, 393, 7, 5, 2, 2, 393, 395, 3, 2,
	2, 2, 394, 388, 3, 2, 2, 2, 394, 395, 3, 2, 2, 2, 395, 49, 3, 2, 2, 2,
	396, 397, 9, 8, 2, 2, 397, 51, 3, 2, 2, 2, 398, 406, 5, 56, 29, 2, 399,
	401, 7, 18, 2, 2, 400, 399, 3, 2, 2, 2, 400, 401, 3, 2, 2, 2, 401, 402,
	3, 2, 2, 2, 402, 404, 5, 94, 48, 2, 403, 405, 5, 54, 28, 2, 404, 403, 3,
	2, 2, 2, 404, 405, 3, 2, 2, 2, 405, 407, 3, 2, 2, 2, 406, 400, 3, 2, 2,
	2, 406, 407, 3, 2, 2, 2, 407, 53, 3, 2, 2, 2, 408, 409, 7, 4, 2, 2, 409,
	414, 5, 94, 48, 2, 410, 411, 7, 3, 2, 2, 411, 413, 5, 94, 48, 2, 412, 410,
	3, 2, 2, 2, 413, 416, 3, 2, 2, 2, 414, 412, 3, 2, 2, 2, 414, 415, 3, 2,
	2, 2, 415, 417, 3, 2, 2, 2, 416, 414, 3, 2, 2, 2, 417, 418, 7, 5, 2, 2,
	418, 55, 3, 2, 2, 2, 419, 449, 5, 92, 47, 2, 420, 421, 7, 4, 2, 2, 421,
	422, 5, 20, 11, 2, 422, 423, 7, 5, 2, 2, 423, 449, 3, 2, 2, 2, 424, 425,
	7, 177, 2, 2, 425, 426, 7, 4, 2, 2, 426, 431, 5, 58, 30, 2, 427, 428, 7,
	3, 2, 2, 428, 430, 5, 58, 30, 2, 429, 427, 3, 2, 2, 2, 430, 433, 3, 2,
	2, 2, 431, 429, 3, 2, 2, 2, 431, 432, 3, 2, 2, 2, 432, 434, 3, 2, 2, 2,
	433, 431, 3, 2, 2, 2, 434, 437, 7, 5, 2, 2, 435, 436, 7, 186, 2, 2, 436,
	438, 7, 119, 2, 2, 437, 435, 3, 2, 2, 2, 437, 438, 3, 2, 2, 2, 438, 449,
	3, 2, 2, 2, 439, 440, 7, 92, 2, 2, 440, 441, 7, 4, 2, 2, 441, 442, 5, 20,
	11, 2, 442, 443, 7, 5, 2, 2, 443, 449, 3, 2, 2, 2, 444, 445, 7, 4, 2, 2,
	445, 446, 5, 42, 22, 2, 446, 447, 7, 5, 2, 2, 447, 449, 3, 2, 2, 2, 448,
	419, 3, 2, 2, 2, 448, 420, 3, 2, 2, 2, 448, 424, 3, 2, 2, 2, 448, 439,
	3, 2, 2, 2, 448, 444, 3, 2, 2, 2, 449, 57, 3, 2, 2, 2, 450, 451, 5, 60,
	31, 2, 451, 59, 3, 2, 2, 2, 452, 453, 8, 31, 1, 2, 453, 457, 5, 62, 32,
	2, 454, 455, 7, 110, 2, 2, 455, 457, 5, 60, 31, 5, 456, 452, 3, 2, 2, 2,
	456, 454, 3, 2, 2, 2, 457, 466, 3, 2, 2, 2, 458, 459, 12, 4, 2, 2, 459,
	460, 7, 15, 2, 2, 460, 465, 5, 60, 31, 5, 461, 462, 12, 3, 2, 2, 462, 463,
	7, 117, 2, 2, 463, 465, 5, 60, 31, 4, 464, 458, 3, 2, 2, 2, 464, 461, 3,
	2, 2, 2, 465, 468, 3, 2, 2, 2, 466, 464, 3, 2, 2, 2, 466, 467, 3, 2, 2,
	2, 467, 61, 3, 2, 2, 2, 468, 466, 3, 2, 2, 2, 469, 471, 5, 66, 34, 2, 470,
	472, 5, 64, 33, 2, 471, 470, 3, 2, 2, 2, 471, 472, 3, 2, 2, 2, 472, 63,
	3, 2, 2, 2, 473, 474, 5, 72, 37, 2, 474, 475, 5, 66, 34, 2, 475, 535, 3,
	2, 2, 2, 476, 477, 5, 72, 37, 2, 477, 478, 5, 74, 38, 2, 478, 479, 7, 4,
	2, 2, 479, 480, 5, 20, 11, 2, 480, 481, 7, 5, 2, 2, 481, 535, 3, 2, 2,
	2, 482, 484, 7, 110, 2, 2, 483, 482, 3, 2, 2, 2, 483, 484, 3, 2, 2, 2,
	484, 485, 3, 2, 2, 2, 485, 486, 7, 22, 2, 2, 486, 487, 5, 66, 34, 2, 487,
	488, 7, 15, 2, 2, 488, 489, 5, 66, 34, 2, 489, 535, 3, 2, 2, 2, 490, 492,
	7, 110, 2, 2, 491, 490, 3, 2, 2, 2, 491, 492, 3, 2, 2, 2, 492, 493, 3,
	2, 2, 2, 493, 494, 7, 79, 2, 2, 494, 495, 7, 4, 2, 2, 495, 500, 5, 58,
	30, 2, 496, 497, 7, 3, 2, 2, 497, 499, 5, 58, 30, 2, 498, 496, 3, 2, 2,
	2, 499, 502, 3, 2, 2, 2, 500, 498, 3, 2, 2, 2, 500, 501, 3, 2, 2, 2, 501,
	503, 3, 2, 2, 2, 502, 500, 3, 2, 2, 2, 503, 504, 7, 5, 2, 2, 504, 535,
	3, 2, 2, 2, 505, 507, 7, 110, 2, 2, 506, 505, 3, 2, 2, 2, 506, 507, 3,
	2, 2, 2, 507, 508, 3, 2, 2, 2, 508, 509, 7, 79, 2, 2, 509, 510, 7, 4, 2,
	2, 510, 511, 5, 20, 11, 2, 511, 512, 7, 5, 2, 2, 512, 535, 3, 2, 2, 2,
	513, 515, 7, 110, 2, 2, 514, 513, 3, 2, 2, 2, 514, 515, 3, 2, 2, 2, 515,
	516, 3, 2, 2, 2, 516, 517, 7, 95, 2, 2, 517, 520, 5, 66, 34, 2, 518, 519,
	7, 55, 2, 2, 519, 521, 5, 66, 34, 2, 520, 518, 3, 2, 2, 2, 520, 521, 3,
	2, 2, 2, 521, 535, 3, 2, 2, 2, 522, 524, 7, 88, 2, 2, 523, 525, 7, 110,
	2, 2, 524, 523, 3, 2, 2, 2, 524, 525, 3, 2, 2, 2, 525, 526, 3, 2, 2, 2,
	526, 535, 7, 111, 2, 2, 527, 529, 7, 88, 2, 2, 528, 530, 7, 110, 2, 2,
	529, 528, 3, 2, 2, 2, 529, 530, 3, 2, 2, 2, 530, 531, 3, 2, 2, 2, 531,
	532, 7, 50, 2, 2, 532, 533, 7, 68, 2, 2, 533, 535, 5, 66, 34, 2, 534, 473,
	3, 2, 2, 2, 534, 476, 3, 2, 2, 2, 534, 483, 3, 2, 2, 2, 534, 491, 3, 2,
	2, 2, 534, 506, 3, 2, 2, 2, 534, 514, 3, 2, 2, 2, 534, 522, 3, 2, 2, 2,
	534, 527, 3, 2, 2, 2, 535, 65, 3, 2, 2, 2, 536, 537, 8, 34, 1, 2, 537,
	541, 5, 68, 35, 2, 538, 539, 9, 9, 2, 2, 539, 541, 5, 66, 34, 6, 540, 536,
	3, 2, 2, 2, 540, 538, 3, 2, 2, 2, 541, 553, 3, 2, 2, 2, 542, 543, 12, 5,
	2, 2, 543, 544, 9, 10, 2, 2, 544, 552, 5, 66, 34, 6, 545, 546, 12, 4, 2,
	2, 546, 547, 9, 9, 2, 2, 547, 552, 5, 66, 34, 5, 548, 549, 12, 3, 2, 2,
	549, 550, 7, 202, 2, 2, 550, 552, 5, 66, 34, 4, 551, 542, 3, 2, 2, 2, 551,
	545, 3, 2, 2, 2, 551, 548, 3, 2, 2, 2, 552, 555, 3, 2, 2, 2, 553, 551,
	3, 2, 2, 2, 553, 554, 3, 2, 2, 2, 554, 67, 3, 2, 2, 2, 555, 553, 3, 2,
	2, 2, 556, 557, 8, 35, 1, 2, 557, 782, 7, 111, 2, 2, 558, 559, 5, 94, 48,
	2, 559, 560, 5, 70, 36, 2, 560, 782, 3, 2, 2, 2, 561, 562, 7, 215, 2, 2,
	562, 782, 5, 70, 36, 2, 563, 782, 5, 96, 49, 2, 564, 782, 5, 76, 39, 2,
	565, 782, 5, 70, 36, 2, 566, 782, 7, 205, 2, 2, 567, 782, 7, 7, 2, 2, 568,
	569, 7, 125, 2, 2, 569, 570, 7, 4, 2, 2, 570, 571, 5, 66, 34, 2, 571, 572,
	7, 79, 2, 2, 572, 573, 5, 66, 34, 2, 573, 574, 7, 5, 2, 2, 574, 782, 3,
	2, 2, 2, 575, 576, 7, 4, 2, 2, 576, 579, 5, 58, 30, 2, 577, 578, 7, 3,
	2, 2, 578, 580, 5, 58, 30, 2, 579, 577, 3, 2, 2, 2, 580, 581, 3, 2, 2,
	2, 581, 579, 3, 2, 2, 2, 581, 582, 3, 2, 2, 2, 582, 583, 3, 2, 2, 2, 583,
	584, 7, 5, 2, 2, 584, 782, 3, 2, 2, 2, 585, 586, 7, 143, 2, 2, 586, 587,
	7, 4, 2, 2, 587, 592, 5, 58, 30, 2, 588, 589, 7, 3, 2, 2, 589, 591, 5,
	58, 30, 2, 590, 588, 3, 2, 2, 2, 591, 594, 3, 2, 2, 2, 592, 590, 3, 2,
	2, 2, 592, 593, 3, 2, 2, 2, 593, 595, 3, 2, 2, 2, 594, 592, 3, 2, 2, 2,
	595, 596, 7, 5, 2, 2, 596, 782, 3, 2, 2, 2, 597, 598, 5, 92, 47, 2, 598,
	599, 7, 4, 2, 2, 599, 600, 7, 199, 2, 2, 600, 602, 7, 5, 2, 2, 601, 603,
	5, 86, 44, 2, 602, 601, 3, 2, 2, 2, 602, 603, 3, 2, 2, 2, 603, 605, 3,
	2, 2, 2, 604, 606, 5, 88, 45, 2, 605, 604, 3, 2, 2, 2, 605, 606, 3, 2,
	2, 2, 606, 782, 3, 2, 2, 2, 607, 608, 5, 92, 47, 2, 608, 620, 7, 4, 2,
	2, 609, 611, 5, 38, 20, 2, 610, 609, 3, 2, 2, 2, 610, 611, 3, 2, 2, 2,
	611, 612, 3, 2, 2, 2, 612, 617, 5, 58, 30, 2, 613, 614, 7, 3, 2, 2, 614,
	616, 5, 58, 30, 2, 615, 613, 3, 2, 2, 2, 616, 619, 3, 2, 2, 2, 617, 615,
	3, 2, 2, 2, 617, 618, 3, 2, 2, 2, 618, 621, 3, 2, 2, 2, 619, 617, 3, 2,
	2, 2, 620, 610, 3, 2, 2, 2, 620, 621, 3, 2, 2, 2, 621, 632, 3, 2, 2, 2,
	622, 623, 7, 118, 2, 2, 623, 624, 7, 23, 2, 2, 624, 629, 5, 26, 14, 2,
	625, 626, 7, 3, 2, 2, 626, 628, 5, 26, 14, 2, 627, 625, 3, 2, 2, 2, 628,
	631, 3, 2, 2, 2, 629, 627, 3, 2, 2, 2, 629, 630, 3, 2, 2, 2, 630, 633,
	3, 2, 2, 2, 631, 629, 3, 2, 2, 2, 632, 622, 3, 2, 2, 2, 632, 633, 3, 2,
	2, 2, 633, 634, 3, 2, 2, 2, 634, 636, 7, 5, 2, 2, 635, 637, 5, 86, 44,
	2, 636, 635, 3, 2, 2, 2, 636, 637, 3, 2, 2, 2, 637, 639, 3, 2, 2, 2, 638,
	640, 5, 88, 45, 2, 639, 638, 3, 2, 2, 2, 639, 640, 3, 2, 2, 2, 640, 782,
	3, 2, 2, 2, 641, 642, 5, 94, 48, 2, 642, 643, 7, 8, 2, 2, 643, 644, 5,
	58, 30, 2, 644, 782, 3, 2, 2, 2, 645, 654, 7, 4, 2, 2, 646, 651, 5, 94,
	48, 2, 647, 648, 7, 3, 2, 2, 648, 650, 5, 94, 48, 2, 649, 647, 3, 2, 2,
	2, 650, 653, 3, 2, 2, 2, 651, 649, 3, 2, 2, 2, 651, 652, 3, 2, 2, 2, 652,
	655, 3, 2, 2, 2, 653, 651, 3, 2, 2, 2, 654, 646, 3, 2, 2, 2, 654, 655,
	3, 2, 2, 2, 655, 656, 3, 2, 2, 2, 656, 657, 7, 5, 2, 2, 657, 658, 7, 8,
	2, 2, 658, 782, 5, 58, 30, 2, 659, 660, 7, 4, 2, 2, 660, 661, 5, 20, 11,
	2, 661, 662, 7, 5, 2, 2, 662, 782, 3, 2, 2, 2, 663, 664, 7, 59, 2, 2, 664,
	665, 7, 4, 2, 2, 665, 666, 5, 20, 11, 2, 666, 667, 7, 5, 2, 2, 667, 782,
	3, 2, 2, 2, 668, 669, 7, 26, 2, 2, 669, 671, 5, 66, 34, 2, 670, 672, 5,
	84, 43, 2, 671, 670, 3, 2, 2, 2, 672, 673, 3, 2, 2, 2, 673, 671, 3, 2,
	2, 2, 673, 674, 3, 2, 2, 2, 674, 677, 3, 2, 2, 2, 675, 676, 7, 53, 2, 2,
	676, 678, 5, 58, 30, 2, 677, 675, 3, 2, 2, 2, 677, 678, 3, 2, 2, 2, 678,
	679, 3, 2, 2, 2, 679, 680, 7, 54, 2, 2, 680, 782, 3, 2, 2, 2, 681, 683,
	7, 26, 2, 2, 682, 684, 5, 84, 43, 2, 683, 682, 3, 2, 2, 2, 684, 685, 3,
	2, 2, 2, 685, 683, 3, 2, 2, 2, 685, 686, 3, 2, 2, 2, 686, 689, 3, 2, 2,
	2, 687, 688, 7, 53, 2, 2, 688, 690, 5, 58, 30, 2, 689, 687, 3, 2, 2, 2,
	689, 690, 3, 2, 2, 2, 690, 691, 3, 2, 2, 2, 691, 692, 7, 54, 2, 2, 692,
	782, 3, 2, 2, 2, 693, 694, 7, 27, 2, 2, 694, 695, 7, 4, 2, 2, 695, 696,
	5, 58, 30, 2, 696, 697, 7, 18, 2, 2, 697, 698, 5, 78, 40, 2, 698, 699,
	7, 5, 2, 2, 699, 782, 3, 2, 2, 2, 700, 701, 7, 171, 2, 2, 701, 702, 7,
	4, 2, 2, 702, 703, 5, 58, 30, 2, 703, 704, 7, 18, 2, 2, 704, 705, 5, 78,
	40, 2, 705, 706, 7, 5, 2, 2, 706, 782, 3, 2, 2, 2, 707, 708, 7, 17, 2,
	2, 708, 717, 7, 9, 2, 2, 709, 714, 5, 58, 30, 2, 710, 711, 7, 3, 2, 2,
	711, 713, 5, 58, 30, 2, 712, 710, 3, 2, 2, 2, 713, 716, 3, 2, 2, 2, 714,
	712, 3, 2, 2, 2, 714, 715, 3, 2, 2, 2, 715, 718, 3, 2, 2, 2, 716, 714,
	3, 2, 2, 2, 717, 709, 3, 2, 2, 2, 717, 718, 3, 2, 2, 2, 718, 719, 3, 2,
	2, 2, 719, 782, 7, 10, 2, 2, 720, 782, 5, 94, 48, 2, 721, 782, 7, 40, 2,
	2, 722, 726, 7, 41, 2, 2, 723, 724, 7, 4, 2, 2, 724, 725, 7, 206, 2, 2,
	725, 727, 7, 5, 2, 2, 726, 723, 3, 2, 2, 2, 726, 727, 3, 2, 2, 2, 727,
	782, 3, 2, 2, 2, 728, 732, 7, 42, 2, 2, 729, 730, 7, 4, 2, 2, 730, 731,
	7, 206, 2, 2, 731, 733, 7, 5, 2, 2, 732, 729, 3, 2, 2, 2, 732, 733, 3,
	2, 2, 2, 733, 782, 3, 2, 2, 2, 734, 738, 7, 97, 2, 2, 735, 736, 7, 4, 2,
	2, 736, 737, 7, 206, 2, 2, 737, 739, 7, 5, 2, 2, 738, 735, 3, 2, 2, 2,
	738, 739, 3, 2, 2, 2, 739, 782, 3, 2, 2, 2, 740, 744, 7, 98, 2, 2, 741,
	742, 7, 4, 2, 2, 742, 743, 7, 206, 2, 2, 743, 745, 7, 5, 2, 2, 744, 741,
	3, 2, 2, 2, 744, 745, 3, 2, 2, 2, 745, 782, 3, 2, 2, 2, 746, 747, 7, 158,
	2, 2, 747, 748, 7, 4, 2, 2, 748, 749, 5, 66, 34, 2, 749, 750, 7, 68, 2,
	2, 750, 753, 5, 66, 34, 2, 751, 752, 7, 66, 2, 2, 752, 754, 5, 66, 34,
	2, 753, 751, 3, 2, 2, 2, 753, 754, 3, 2, 2, 2, 754, 755, 3, 2, 2, 2, 755,
	756, 7, 5, 2, 2, 756, 782, 3, 2, 2, 2, 757, 758, 7, 61, 2, 2, 758, 759,
	7, 4, 2, 2, 759, 760, 5, 94, 48, 2, 760, 761, 7, 68, 2, 2, 761, 762, 5,
	66, 34, 2, 762, 763, 7, 5, 2, 2, 763, 782, 3, 2, 2, 2, 764, 765, 7, 4,
	2, 2, 765, 766, 5, 58, 30, 2, 766, 767, 7, 5, 2, 2, 767, 782, 3, 2, 2,
	2, 768, 769, 7, 75, 2, 2, 769, 778, 7, 4, 2, 2, 770, 775, 5, 92, 47, 2,
	771, 772, 7, 3, 2, 2, 772, 774, 5, 92, 47, 2, 773, 771, 3, 2, 2, 2, 774,
	777, 3, 2, 2, 2, 775, 773, 3, 2, 2, 2, 775, 776, 3, 2, 2, 2, 776, 779,
	3, 2, 2, 2, 777, 775, 3, 2, 2, 2, 778, 770, 3, 2, 2, 2, 778, 779, 3, 2,
	2, 2, 779, 780, 3, 2, 2, 2, 780, 782, 7, 5, 2, 2, 781, 556, 3, 2, 2, 2,
	781, 558, 3, 2, 2, 2, 781, 561, 3, 2, 2, 2, 781, 563, 3, 2, 2, 2, 781,
	564, 3, 2, 2, 2, 781, 565, 3, 2, 2, 2, 781, 566, 3, 2, 2, 2, 781, 567,
	3, 2, 2, 2, 781, 568, 3, 2, 2, 2, 781, 575, 3, 2, 2, 2, 781, 585, 3, 2,
	2, 2, 781, 597, 3, 2, 2, 2, 781, 607, 3, 2, 2, 2, 781, 641, 3, 2, 2, 2,
	781, 645, 3, 2, 2, 2, 781, 659, 3, 2, 2, 2, 781, 663, 3, 2, 2, 2, 781,
	668, 3, 2, 2, 2, 781, 681, 3, 2, 2, 2, 781, 693, 3, 2, 2, 2, 781, 700,
	3, 2, 2, 2, 781, 707, 3, 2, 2, 2, 781, 720, 3, 2, 2, 2, 781, 721, 3, 2,
	2, 2, 781, 722, 3, 2, 2, 2, 781, 728, 3, 2, 2, 2, 781, 734, 3, 2, 2, 2,
	781, 740, 3, 2, 2, 2, 781, 746, 3, 2, 2, 2, 781, 757, 3, 2, 2, 2, 781,
	764, 3, 2, 2, 2, 781, 768, 3, 2, 2, 2, 782, 793, 3, 2, 2, 2, 783, 784,
	12, 14, 2, 2, 784, 785, 7, 9, 2, 2, 785, 786, 5, 66, 34, 2, 786, 787, 7,
	10, 2, 2, 787, 792, 3, 2, 2, 2, 788, 789, 12, 12, 2, 2, 789, 790, 7, 6,
	2, 2, 790, 792, 5, 94, 48, 2, 791, 783, 3, 2, 2, 2, 791, 788, 3, 2, 2,
	2, 792, 795, 3, 2, 2, 2, 793, 791, 3, 2, 2, 2, 793, 794, 3, 2, 2, 2, 794,
	69, 3, 2, 2, 2, 795, 793, 3, 2, 2, 2, 796, 803, 7, 203, 2, 2, 797, 800,
	7, 204, 2, 2, 798, 799, 7, 173, 2, 2, 799, 801, 7, 203, 2, 2, 800, 798,
	3, 2, 2, 2, 800, 801, 3, 2, 2, 2, 801, 803, 3, 2, 2, 2, 802, 796, 3, 2,
	2, 2, 802, 797, 3, 2, 2, 2, 803, 71, 3, 2, 2, 2, 804, 805, 9, 11, 2, 2,
	805, 73, 3, 2, 2, 2, 806, 807, 9, 12, 2, 2, 807, 75, 3, 2, 2, 2, 808, 809,
	9, 13, 2, 2, 809, 77, 3, 2, 2, 2, 810, 811, 8, 40, 1, 2, 811, 812, 7, 17,
	2, 2, 812, 813, 7, 193, 2, 2, 813, 814, 5, 78, 40, 2, 814, 815, 7, 195,
	2, 2, 815, 853, 3, 2, 2, 2, 816, 817, 7, 100, 2, 2, 817, 818, 7, 193, 2,
	2, 818, 819, 5, 78, 40, 2, 819, 820, 7, 3, 2, 2, 820, 821, 5, 78, 40, 2,
	821, 822, 7, 195, 2, 2, 822, 853, 3, 2, 2, 2, 823, 824, 7, 143, 2, 2, 824,
	825, 7, 4, 2, 2, 825, 826, 5, 94, 48, 2, 826, 833, 5, 78, 40, 2, 827, 828,
	7, 3, 2, 2, 828, 829, 5, 94, 48, 2, 829, 830, 5, 78, 40, 2, 830, 832, 3,
	2, 2, 2, 831, 827, 3, 2, 2, 2, 832, 835, 3, 2, 2, 2, 833, 831, 3, 2, 2,
	2, 833, 834, 3, 2, 2, 2, 834, 836, 3, 2, 2, 2, 835, 833, 3, 2, 2, 2, 836,
	837, 7, 5, 2, 2, 837, 853, 3, 2, 2, 2, 838, 850, 5, 82, 42, 2, 839, 840,
	7, 4, 2, 2, 840, 845, 5, 80, 41, 2, 841, 842, 7, 3, 2, 2, 842, 844, 5,
	80, 41, 2, 843, 841, 3, 2, 2, 2, 844, 847, 3, 2, 2, 2, 845, 843, 3, 2,
	2, 2, 845, 846, 3, 2, 2, 2, 846, 848, 3, 2, 2, 2, 847, 845, 3, 2, 2, 2,
	848, 849, 7, 5, 2, 2, 849, 851, 3, 2, 2, 2, 850, 839, 3, 2, 2, 2, 850,
	851, 3, 2, 2, 2, 851, 853, 3, 2, 2, 2, 852, 810, 3, 2, 2, 2, 852, 816,
	3, 2, 2, 2, 852, 823, 3, 2, 2, 2, 852, 838, 3, 2, 2, 2, 853, 858, 3, 2,
	2, 2, 854, 855, 12, 7, 2, 2, 855, 857, 7, 17, 2, 2, 856, 854, 3, 2, 2,
	2, 857, 860, 3, 2, 2, 2, 858, 856, 3, 2, 2, 2, 858, 859, 3, 2, 2, 2, 859,
	79, 3, 2, 2, 2, 860, 858, 3, 2, 2, 2, 861, 864, 7, 206, 2, 2, 862, 864,
	5, 78, 40, 2, 863, 861, 3, 2, 2, 2, 863, 862, 3, 2, 2, 2, 864, 81, 3, 2,
	2, 2, 865, 870, 7, 213, 2, 2, 866, 870, 7, 214, 2, 2, 867, 870, 7, 215,
	2, 2, 868, 870, 5, 94, 48, 2, 869, 865, 3, 2, 2, 2, 869, 866, 3, 2, 2,
	2, 869, 867, 3, 2, 2, 2, 869, 868, 3, 2, 2, 2, 870, 83, 3, 2, 2, 2, 871,
	872, 7, 184, 2, 2, 872, 873, 5, 58, 30, 2, 873, 874, 7, 164, 2, 2, 874,
	875, 5, 58, 30, 2, 875, 85, 3, 2, 2, 2, 876, 877, 7, 63, 2, 2, 877, 878,
	7, 4, 2, 2, 878, 879, 7, 185, 2, 2, 879, 880, 5, 60, 31, 2, 880, 881, 7,
	5, 2, 2, 881, 87, 3, 2, 2, 2, 882, 883, 7, 122, 2, 2, 883, 894, 7, 4, 2,
	2, 884, 885, 7, 123, 2, 2, 885, 886, 7, 23, 2, 2, 886, 891, 5, 58, 30,
	2, 887, 888, 7, 3, 2, 2, 888, 890, 5, 58, 30, 2, 889, 887, 3, 2, 2, 2,
	890, 893, 3, 2, 2, 2, 891, 889, 3, 2, 2, 2, 891, 892, 3, 2, 2, 2, 892,
	895, 3, 2, 2, 2, 893, 891, 3, 2, 2, 2, 894, 884, 3, 2, 2, 2, 894, 895,
	3, 2, 2, 2, 895, 906, 3, 2, 2, 2, 896, 897, 7, 118, 2, 2, 897, 898, 7,
	23, 2, 2, 898, 903, 5, 26, 14, 2, 899, 900, 7, 3, 2, 2, 900, 902, 5, 26,
	14, 2, 901, 899, 3, 2, 2, 2, 902, 905, 3, 2, 2, 2, 903, 901, 3, 2, 2, 2,
	903, 904, 3, 2, 2, 2, 904, 907, 3, 2, 2, 2, 905, 903, 3, 2, 2, 2, 906,
	896, 3, 2, 2, 2, 906, 907, 3, 2, 2, 2, 907, 908, 3, 2, 2, 2, 908, 909,
	7, 5, 2, 2, 909, 89, 3, 2, 2, 2, 910, 915, 7, 148, 2, 2, 911, 915, 7, 47,
	2, 2, 912, 915, 7, 83, 2, 2, 913, 915, 5, 94, 48, 2, 914, 910, 3, 2, 2,
	2, 914, 911, 3, 2, 2, 2, 914, 912, 3, 2, 2, 2, 914, 913, 3, 2, 2, 2, 915,
	91, 3, 2, 2, 2, 916, 921, 5, 94, 48, 2, 917, 918, 7, 6, 2, 2, 918, 920,
	5, 94, 48, 2, 919, 917, 3, 2, 2, 2, 920, 923, 3, 2, 2, 2, 921, 919, 3,
	2, 2, 2, 921, 922, 3, 2, 2, 2, 922, 93, 3, 2, 2, 2, 923, 921, 3, 2, 2,
	2, 924, 930, 7, 209, 2, 2, 925, 930, 7, 211, 2, 2, 926, 930, 5, 98, 50,
	2, 927, 930, 7, 212, 2, 2, 928, 930, 7, 210, 2, 2, 929, 924, 3, 2, 2, 2,
	929, 925, 3, 2, 2, 2, 929, 926, 3, 2, 2, 2, 929, 927, 3, 2, 2, 2, 929,
	928, 3, 2, 2, 2, 930, 95, 3, 2, 2, 2, 931, 935, 7, 207, 2, 2, 932, 935,
	7, 208, 2, 2, 933, 935, 7, 206, 2, 2, 934, 931, 3, 2, 2, 2, 934, 932, 3,
	2, 2, 2, 934, 933, 3, 2, 2, 2, 935, 97, 3, 2, 2, 2, 936, 937, 9, 14, 2,
	2, 937, 99, 3, 2, 2, 2, 119, 110, 117, 122, 128, 134, 142, 159, 162, 166,
	174, 180, 183, 185, 197, 204, 208, 212, 216, 223, 232, 235, 239, 244, 248,
	251, 258, 269, 272, 282, 285, 288, 296, 299, 303, 307, 318, 321, 328, 347,
	351, 355, 359, 363, 367, 369, 380, 385, 394, 400, 404, 406, 414, 431, 437,
	448, 456, 464, 466, 471, 483, 491, 500, 506, 514, 520, 524, 529, 534, 540,
	551, 553, 581, 592, 602, 605, 610, 617, 620, 629, 632, 636, 639, 651, 654,
	673, 677, 685, 689, 714, 717, 726, 732, 738, 744, 753, 775, 778, 781, 791,
	793, 800, 802, 833, 845, 850, 852, 858, 863, 869, 891, 894, 903, 906, 914,
	921, 929, 934,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "','", "'('", "')'", "'.'", "'?'", "'->'", "'['", "']'", "'ADD'", "'ALL'",
	"'ALTER'", "'ANALYZE'", "'AND'", "'ANY'", "'ARRAY'", "'AS'", "'ASC'", "'AT'",
	"'BERNOULLI'", "'BETWEEN'", "'BY'", "'CALL'", "'CASCADE'", "'CASE'", "'CAST'",
	"'CATALOGS'", "'COALESCE'", "'COLUMN'", "'COLUMNS'", "'COMMENT'", "'COMMIT'",
	"'COMMITTED'", "'CONSTRAINT'", "'CREATE'", "'CROSS'", "'CUBE'", "'CURRENT'",
	"'CURRENT_DATE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'DATA'", "'DATE'",
	"'DAY'", "'DEALLOCATE'", "'DELETE'", "'DESC'", "'DESCRIBE'", "'DISTINCT'",
	"'DISTRIBUTED'", "'DROP'", "'ELSE'", "'END'", "'ESCAPE'", "'EXCEPT'", "'EXCLUDING'",
	"'EXECUTE'", "'EXISTS'", "'EXPLAIN'", "'EXTRACT'", "'FALSE'", "'FILTER'",
	"'FIRST'", "'FOLLOWING'", "'FOR'", "'FORMAT'", "'FROM'", "'FULL'", "'FUNCTIONS'",
	"'GRANT'", "'GRANTS'", "'GRAPHVIZ'", "'GROUP'", "'GROUPING'", "'HAVING'",
	"'HOUR'", "'IF'", "'IN'", "'INCLUDING'", "'INNER'", "'INPUT'", "'INSERT'",
	"'INTEGER'", "'INTERSECT'", "'INTERVAL'", "'INTO'", "'IS'", "'ISOLATION'",
	"'JOIN'", "'LAST'", "'LATERAL'", "'LEFT'", "'LEVEL'", "'LIKE'", "'LIMIT'",
	"'LOCALTIME'", "'LOCALTIMESTAMP'", "'LOGICAL'", "'MAP'", "'MINUTE'", "'MONTH'",
	"'NATURAL'", "'NFC'", "'NFD'", "'NFKC'", "'NFKD'", "'NO'", "'NORMALIZE'",
	"'NOT'", "'NULL'", "'NULLIF'", "'NULLS'", "'ON'", "'ONLY'", "'OPTION'",
	"'OR'", "'ORDER'", "'ORDINALITY'", "'OUTER'", "'OUTPUT'", "'OVER'", "'PARTITION'",
	"'PARTITIONS'", "'POSITION'", "'PRECEDING'", "'PREPARE'", "'PRIVILEGES'",
	"'PROPERTIES'", "'PUBLIC'", "'RANGE'", "'READ'", "'RECURSIVE'", "'RENAME'",
	"'REPEATABLE'", "'REPLACE'", "'RESET'", "'RESTRICT'", "'REVOKE'", "'RIGHT'",
	"'ROLLBACK'", "'ROLLUP'", "'ROW'", "'ROWS'", "'SCHEMA'", "'SCHEMAS'", "'SECOND'",
	"'SELECT'", "'SERIALIZABLE'", "'SESSION'", "'SET'", "'SETS'", "'SHOW'",
	"'SMALLINT'", "'SOME'", "'START'", "'STATS'", "'SUBSTRING'", "'SYSTEM'",
	"'TABLE'", "'TABLES'", "'TABLESAMPLE'", "'TEXT'", "'THEN'", "'TIME'", "'TIMESTAMP'",
	"'TINYINT'", "'TO'", "'TRANSACTION'", "'TRUE'", "'TRY_CAST'", "'TYPE'",
	"'UESCAPE'", "'UNBOUNDED'", "'UNCOMMITTED'", "'UNION'", "'UNNEST'", "'USE'",
	"'USING'", "'VALIDATE'", "'VALUES'", "'VERBOSE'", "'VIEW'", "'WHEN'", "'WHERE'",
	"'WITH'", "'WORK'", "'WRITE'", "'YEAR'", "'ZONE'", "'='", "", "'<'", "'<='",
	"'>'", "'>='", "'+'", "'-'", "'*'", "'/'", "'%'", "'||'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "ADD", "ALL", "ALTER", "ANALYZE", "AND",
	"ANY", "ARRAY", "AS", "ASC", "AT", "BERNOULLI", "BETWEEN", "BY", "CALL",
	"CASCADE", "CASE", "CAST", "CATALOGS", "COALESCE", "COLUMN", "COLUMNS",
	"COMMENT", "COMMIT", "COMMITTED", "CONSTRAINT", "CREATE", "CROSS", "CUBE",
	"CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATA",
	"DATE", "DAY", "DEALLOCATE", "DELETE", "DESC", "DESCRIBE", "DISTINCT",
	"DISTRIBUTED", "DROP", "ELSE", "END", "ESCAPE", "EXCEPT", "EXCLUDING",
	"EXECUTE", "EXISTS", "EXPLAIN", "EXTRACT", "FALSE", "FILTER", "FIRST",
	"FOLLOWING", "FOR", "FORMAT", "FROM", "FULL", "FUNCTIONS", "GRANT", "GRANTS",
	"GRAPHVIZ", "GROUP", "GROUPING", "HAVING", "HOUR", "IF", "IN", "INCLUDING",
	"INNER", "INPUT", "INSERT", "INTEGER", "INTERSECT", "INTERVAL", "INTO",
	"IS", "ISOLATION", "JOIN", "LAST", "LATERAL", "LEFT", "LEVEL", "LIKE",
	"LIMIT", "LOCALTIME", "LOCALTIMESTAMP", "LOGICAL", "MAP", "MINUTE", "MONTH",
	"NATURAL", "NFC", "NFD", "NFKC", "NFKD", "NO", "NORMALIZE", "NOT", "NULL",
	"NULLIF", "NULLS", "ON", "ONLY", "OPTION", "OR", "ORDER", "ORDINALITY",
	"OUTER", "OUTPUT", "OVER", "PARTITION", "PARTITIONS", "POSITION", "PRECEDING",
	"PREPARE", "PRIVILEGES", "PROPERTIES", "PUBLIC", "RANGE", "READ", "RECURSIVE",
	"RENAME", "REPEATABLE", "REPLACE", "RESET", "RESTRICT", "REVOKE", "RIGHT",
	"ROLLBACK", "ROLLUP", "ROW", "ROWS", "SCHEMA", "SCHEMAS", "SECOND", "SELECT",
	"SERIALIZABLE", "SESSION", "SET", "SETS", "SHOW", "SMALLINT", "SOME", "START",
	"STATS", "SUBSTRING", "SYSTEM", "TABLE", "TABLES", "TABLESAMPLE", "TEXT",
	"THEN", "TIME", "TIMESTAMP", "TINYINT", "TO", "TRANSACTION", "TRUE", "TRY_CAST",
	"TYPE", "UESCAPE", "UNBOUNDED", "UNCOMMITTED", "UNION", "UNNEST", "USE",
	"USING", "VALIDATE", "VALUES", "VERBOSE", "VIEW", "WHEN", "WHERE", "WITH",
	"WORK", "WRITE", "YEAR", "ZONE", "EQ", "NEQ", "LT", "LTE", "GT", "GTE",
	"PLUS", "MINUS", "ASTERISK", "SLASH", "PERCENT", "CONCAT", "STRING", "UNICODE_STRING",
	"BINARY_LITERAL", "INTEGER_VALUE", "DECIMAL_VALUE", "DOUBLE_VALUE", "IDENTIFIER",
	"DIGIT_IDENTIFIER", "QUOTED_IDENTIFIER", "BACKQUOTED_IDENTIFIER", "TIME_WITH_TIME_ZONE",
	"TIMESTAMP_WITH_TIME_ZONE", "DOUBLE_PRECISION", "SIMPLE_COMMENT", "BRACKETED_COMMENT",
	"WS", "UNRECOGNIZED", "DELIMITER",
}

var ruleNames = []string{
	"singleStatement", "singleExpression", "statement", "with", "tableElement",
	"columnDefinition", "likeClause", "properties", "property", "query", "queryTerm",
	"queryPrimary", "sortItem", "querySpecification", "groupBy", "groupingElement",
	"groupingExpressions", "namedQuery", "setQuantifier", "selectItem", "relation",
	"joinType", "joinCriteria", "sampledRelation", "sampleType", "aliasedRelation",
	"columnAliases", "relationPrimary", "expression", "booleanExpression",
	"predicated", "predicate", "valueExpression", "primaryExpression", "stringSql",
	"comparisonOperator", "comparisonQuantifier", "booleanValue", "typeSql",
	"typeParameter", "baseType", "whenClause", "filter", "over", "privilege",
	"qualifiedName", "identifier", "number", "nonReserved",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type SqlParser struct {
	*antlr.BaseParser
}

func NewSqlParser(input antlr.TokenStream) *SqlParser {
	this := new(SqlParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "Sql.g4"

	return this
}

// SqlParser tokens.
const (
	SqlParserEOF                      = antlr.TokenEOF
	SqlParserT__0                     = 1
	SqlParserT__1                     = 2
	SqlParserT__2                     = 3
	SqlParserT__3                     = 4
	SqlParserT__4                     = 5
	SqlParserT__5                     = 6
	SqlParserT__6                     = 7
	SqlParserT__7                     = 8
	SqlParserADD                      = 9
	SqlParserALL                      = 10
	SqlParserALTER                    = 11
	SqlParserANALYZE                  = 12
	SqlParserAND                      = 13
	SqlParserANY                      = 14
	SqlParserARRAY                    = 15
	SqlParserAS                       = 16
	SqlParserASC                      = 17
	SqlParserAT                       = 18
	SqlParserBERNOULLI                = 19
	SqlParserBETWEEN                  = 20
	SqlParserBY                       = 21
	SqlParserCALL                     = 22
	SqlParserCASCADE                  = 23
	SqlParserCASE                     = 24
	SqlParserCAST                     = 25
	SqlParserCATALOGS                 = 26
	SqlParserCOALESCE                 = 27
	SqlParserCOLUMN                   = 28
	SqlParserCOLUMNS                  = 29
	SqlParserCOMMENT                  = 30
	SqlParserCOMMIT                   = 31
	SqlParserCOMMITTED                = 32
	SqlParserCONSTRAINT               = 33
	SqlParserCREATE                   = 34
	SqlParserCROSS                    = 35
	SqlParserCUBE                     = 36
	SqlParserCURRENT                  = 37
	SqlParserCURRENT_DATE             = 38
	SqlParserCURRENT_TIME             = 39
	SqlParserCURRENT_TIMESTAMP        = 40
	SqlParserDATA                     = 41
	SqlParserDATE                     = 42
	SqlParserDAY                      = 43
	SqlParserDEALLOCATE               = 44
	SqlParserDELETE                   = 45
	SqlParserDESC                     = 46
	SqlParserDESCRIBE                 = 47
	SqlParserDISTINCT                 = 48
	SqlParserDISTRIBUTED              = 49
	SqlParserDROP                     = 50
	SqlParserELSE                     = 51
	SqlParserEND                      = 52
	SqlParserESCAPE                   = 53
	SqlParserEXCEPT                   = 54
	SqlParserEXCLUDING                = 55
	SqlParserEXECUTE                  = 56
	SqlParserEXISTS                   = 57
	SqlParserEXPLAIN                  = 58
	SqlParserEXTRACT                  = 59
	SqlParserFALSE                    = 60
	SqlParserFILTER                   = 61
	SqlParserFIRST                    = 62
	SqlParserFOLLOWING                = 63
	SqlParserFOR                      = 64
	SqlParserFORMAT                   = 65
	SqlParserFROM                     = 66
	SqlParserFULL                     = 67
	SqlParserFUNCTIONS                = 68
	SqlParserGRANT                    = 69
	SqlParserGRANTS                   = 70
	SqlParserGRAPHVIZ                 = 71
	SqlParserGROUP                    = 72
	SqlParserGROUPING                 = 73
	SqlParserHAVING                   = 74
	SqlParserHOUR                     = 75
	SqlParserIF                       = 76
	SqlParserIN                       = 77
	SqlParserINCLUDING                = 78
	SqlParserINNER                    = 79
	SqlParserINPUT                    = 80
	SqlParserINSERT                   = 81
	SqlParserINTEGER                  = 82
	SqlParserINTERSECT                = 83
	SqlParserINTERVAL                 = 84
	SqlParserINTO                     = 85
	SqlParserIS                       = 86
	SqlParserISOLATION                = 87
	SqlParserJOIN                     = 88
	SqlParserLAST                     = 89
	SqlParserLATERAL                  = 90
	SqlParserLEFT                     = 91
	SqlParserLEVEL                    = 92
	SqlParserLIKE                     = 93
	SqlParserLIMIT                    = 94
	SqlParserLOCALTIME                = 95
	SqlParserLOCALTIMESTAMP           = 96
	SqlParserLOGICAL                  = 97
	SqlParserMAP                      = 98
	SqlParserMINUTE                   = 99
	SqlParserMONTH                    = 100
	SqlParserNATURAL                  = 101
	SqlParserNFC                      = 102
	SqlParserNFD                      = 103
	SqlParserNFKC                     = 104
	SqlParserNFKD                     = 105
	SqlParserNO                       = 106
	SqlParserNORMALIZE                = 107
	SqlParserNOT                      = 108
	SqlParserNULL                     = 109
	SqlParserNULLIF                   = 110
	SqlParserNULLS                    = 111
	SqlParserON                       = 112
	SqlParserONLY                     = 113
	SqlParserOPTION                   = 114
	SqlParserOR                       = 115
	SqlParserORDER                    = 116
	SqlParserORDINALITY               = 117
	SqlParserOUTER                    = 118
	SqlParserOUTPUT                   = 119
	SqlParserOVER                     = 120
	SqlParserPARTITION                = 121
	SqlParserPARTITIONS               = 122
	SqlParserPOSITION                 = 123
	SqlParserPRECEDING                = 124
	SqlParserPREPARE                  = 125
	SqlParserPRIVILEGES               = 126
	SqlParserPROPERTIES               = 127
	SqlParserPUBLIC                   = 128
	SqlParserRANGE                    = 129
	SqlParserREAD                     = 130
	SqlParserRECURSIVE                = 131
	SqlParserRENAME                   = 132
	SqlParserREPEATABLE               = 133
	SqlParserREPLACE                  = 134
	SqlParserRESET                    = 135
	SqlParserRESTRICT                 = 136
	SqlParserREVOKE                   = 137
	SqlParserRIGHT                    = 138
	SqlParserROLLBACK                 = 139
	SqlParserROLLUP                   = 140
	SqlParserROW                      = 141
	SqlParserROWS                     = 142
	SqlParserSCHEMA                   = 143
	SqlParserSCHEMAS                  = 144
	SqlParserSECOND                   = 145
	SqlParserSELECT                   = 146
	SqlParserSERIALIZABLE             = 147
	SqlParserSESSION                  = 148
	SqlParserSET                      = 149
	SqlParserSETS                     = 150
	SqlParserSHOW                     = 151
	SqlParserSMALLINT                 = 152
	SqlParserSOME                     = 153
	SqlParserSTART                    = 154
	SqlParserSTATS                    = 155
	SqlParserSUBSTRING                = 156
	SqlParserSYSTEM                   = 157
	SqlParserTABLE                    = 158
	SqlParserTABLES                   = 159
	SqlParserTABLESAMPLE              = 160
	SqlParserTEXT                     = 161
	SqlParserTHEN                     = 162
	SqlParserTIME                     = 163
	SqlParserTIMESTAMP                = 164
	SqlParserTINYINT                  = 165
	SqlParserTO                       = 166
	SqlParserTRANSACTION              = 167
	SqlParserTRUE                     = 168
	SqlParserTRY_CAST                 = 169
	SqlParserTYPE                     = 170
	SqlParserUESCAPE                  = 171
	SqlParserUNBOUNDED                = 172
	SqlParserUNCOMMITTED              = 173
	SqlParserUNION                    = 174
	SqlParserUNNEST                   = 175
	SqlParserUSE                      = 176
	SqlParserUSING                    = 177
	SqlParserVALIDATE                 = 178
	SqlParserVALUES                   = 179
	SqlParserVERBOSE                  = 180
	SqlParserVIEW                     = 181
	SqlParserWHEN                     = 182
	SqlParserWHERE                    = 183
	SqlParserWITH                     = 184
	SqlParserWORK                     = 185
	SqlParserWRITE                    = 186
	SqlParserYEAR                     = 187
	SqlParserZONE                     = 188
	SqlParserEQ                       = 189
	SqlParserNEQ                      = 190
	SqlParserLT                       = 191
	SqlParserLTE                      = 192
	SqlParserGT                       = 193
	SqlParserGTE                      = 194
	SqlParserPLUS                     = 195
	SqlParserMINUS                    = 196
	SqlParserASTERISK                 = 197
	SqlParserSLASH                    = 198
	SqlParserPERCENT                  = 199
	SqlParserCONCAT                   = 200
	SqlParserSTRING                   = 201
	SqlParserUNICODE_STRING           = 202
	SqlParserBINARY_LITERAL           = 203
	SqlParserINTEGER_VALUE            = 204
	SqlParserDECIMAL_VALUE            = 205
	SqlParserDOUBLE_VALUE             = 206
	SqlParserIDENTIFIER               = 207
	SqlParserDIGIT_IDENTIFIER         = 208
	SqlParserQUOTED_IDENTIFIER        = 209
	SqlParserBACKQUOTED_IDENTIFIER    = 210
	SqlParserTIME_WITH_TIME_ZONE      = 211
	SqlParserTIMESTAMP_WITH_TIME_ZONE = 212
	SqlParserDOUBLE_PRECISION         = 213
	SqlParserSIMPLE_COMMENT           = 214
	SqlParserBRACKETED_COMMENT        = 215
	SqlParserWS                       = 216
	SqlParserUNRECOGNIZED             = 217
	SqlParserDELIMITER                = 218
)

// SqlParser rules.
const (
	SqlParserRULE_singleStatement      = 0
	SqlParserRULE_singleExpression     = 1
	SqlParserRULE_statement            = 2
	SqlParserRULE_with                 = 3
	SqlParserRULE_tableElement         = 4
	SqlParserRULE_columnDefinition     = 5
	SqlParserRULE_likeClause           = 6
	SqlParserRULE_properties           = 7
	SqlParserRULE_property             = 8
	SqlParserRULE_query                = 9
	SqlParserRULE_queryTerm            = 10
	SqlParserRULE_queryPrimary         = 11
	SqlParserRULE_sortItem             = 12
	SqlParserRULE_querySpecification   = 13
	SqlParserRULE_groupBy              = 14
	SqlParserRULE_groupingElement      = 15
	SqlParserRULE_groupingExpressions  = 16
	SqlParserRULE_namedQuery           = 17
	SqlParserRULE_setQuantifier        = 18
	SqlParserRULE_selectItem           = 19
	SqlParserRULE_relation             = 20
	SqlParserRULE_joinType             = 21
	SqlParserRULE_joinCriteria         = 22
	SqlParserRULE_sampledRelation      = 23
	SqlParserRULE_sampleType           = 24
	SqlParserRULE_aliasedRelation      = 25
	SqlParserRULE_columnAliases        = 26
	SqlParserRULE_relationPrimary      = 27
	SqlParserRULE_expression           = 28
	SqlParserRULE_booleanExpression    = 29
	SqlParserRULE_predicated           = 30
	SqlParserRULE_predicate            = 31
	SqlParserRULE_valueExpression      = 32
	SqlParserRULE_primaryExpression    = 33
	SqlParserRULE_stringSql            = 34
	SqlParserRULE_comparisonOperator   = 35
	SqlParserRULE_comparisonQuantifier = 36
	SqlParserRULE_booleanValue         = 37
	SqlParserRULE_typeSql              = 38
	SqlParserRULE_typeParameter        = 39
	SqlParserRULE_baseType             = 40
	SqlParserRULE_whenClause           = 41
	SqlParserRULE_filter               = 42
	SqlParserRULE_over                 = 43
	SqlParserRULE_privilege            = 44
	SqlParserRULE_qualifiedName        = 45
	SqlParserRULE_identifier           = 46
	SqlParserRULE_number               = 47
	SqlParserRULE_nonReserved          = 48
)

// ISingleStatementContext is an interface to support dynamic dispatch.
type ISingleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleStatementContext differentiates from other interfaces.
	IsSingleStatementContext()
}

type SingleStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleStatementContext() *SingleStatementContext {
	var p = new(SingleStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_singleStatement
	return p
}

func (*SingleStatementContext) IsSingleStatementContext() {}

func NewSingleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleStatementContext {
	var p = new(SingleStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_singleStatement

	return p
}

func (s *SingleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SingleStatementContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlParserEOF, 0)
}

func (s *SingleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterSingleStatement(s)
	}
}

func (s *SingleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitSingleStatement(s)
	}
}

func (s *SingleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitSingleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) SingleStatement() (localctx ISingleStatementContext) {
	localctx = NewSingleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SqlParserRULE_singleStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(98)
		p.Statement()
	}
	{
		p.SetState(99)
		p.Match(SqlParserEOF)
	}

	return localctx
}

// ISingleExpressionContext is an interface to support dynamic dispatch.
type ISingleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleExpressionContext differentiates from other interfaces.
	IsSingleExpressionContext()
}

type SingleExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleExpressionContext() *SingleExpressionContext {
	var p = new(SingleExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_singleExpression
	return p
}

func (*SingleExpressionContext) IsSingleExpressionContext() {}

func NewSingleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleExpressionContext {
	var p = new(SingleExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_singleExpression

	return p
}

func (s *SingleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SingleExpressionContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlParserEOF, 0)
}

func (s *SingleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterSingleExpression(s)
	}
}

func (s *SingleExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitSingleExpression(s)
	}
}

func (s *SingleExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitSingleExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) SingleExpression() (localctx ISingleExpressionContext) {
	localctx = NewSingleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SqlParserRULE_singleExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(101)
		p.Expression()
	}
	{
		p.SetState(102)
		p.Match(SqlParserEOF)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CopyFrom(ctx *StatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StatementDefaultContext struct {
	*StatementContext
}

func NewStatementDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StatementDefaultContext {
	var p = new(StatementDefaultContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *StatementDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementDefaultContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *StatementDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterStatementDefault(s)
	}
}

func (s *StatementDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitStatementDefault(s)
	}
}

func (s *StatementDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitStatementDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SqlParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	localctx = NewStatementDefaultContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(104)
		p.Query()
	}

	return localctx
}

// IWithContext is an interface to support dynamic dispatch.
type IWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithContext differentiates from other interfaces.
	IsWithContext()
}

type WithContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithContext() *WithContext {
	var p = new(WithContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_with
	return p
}

func (*WithContext) IsWithContext() {}

func NewWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithContext {
	var p = new(WithContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_with

	return p
}

func (s *WithContext) GetParser() antlr.Parser { return s.parser }

func (s *WithContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlParserWITH, 0)
}

func (s *WithContext) AllNamedQuery() []INamedQueryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamedQueryContext)(nil)).Elem())
	var tst = make([]INamedQueryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamedQueryContext)
		}
	}

	return tst
}

func (s *WithContext) NamedQuery(i int) INamedQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedQueryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamedQueryContext)
}

func (s *WithContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(SqlParserRECURSIVE, 0)
}

func (s *WithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterWith(s)
	}
}

func (s *WithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitWith(s)
	}
}

func (s *WithContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitWith(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) With() (localctx IWithContext) {
	localctx = NewWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SqlParserRULE_with)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(106)
		p.Match(SqlParserWITH)
	}
	p.SetState(108)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlParserRECURSIVE {
		{
			p.SetState(107)
			p.Match(SqlParserRECURSIVE)
		}

	}
	{
		p.SetState(110)
		p.NamedQuery()
	}
	p.SetState(115)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SqlParserT__0 {
		{
			p.SetState(111)
			p.Match(SqlParserT__0)
		}
		{
			p.SetState(112)
			p.NamedQuery()
		}

		p.SetState(117)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITableElementContext is an interface to support dynamic dispatch.
type ITableElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableElementContext differentiates from other interfaces.
	IsTableElementContext()
}

type TableElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementContext() *TableElementContext {
	var p = new(TableElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_tableElement
	return p
}

func (*TableElementContext) IsTableElementContext() {}

func NewTableElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementContext {
	var p = new(TableElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_tableElement

	return p
}

func (s *TableElementContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementContext) ColumnDefinition() IColumnDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *TableElementContext) LikeClause() ILikeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILikeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILikeClauseContext)
}

func (s *TableElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterTableElement(s)
	}
}

func (s *TableElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitTableElement(s)
	}
}

func (s *TableElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitTableElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) TableElement() (localctx ITableElementContext) {
	localctx = NewTableElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SqlParserRULE_tableElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(120)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlParserADD, SqlParserALL, SqlParserANALYZE, SqlParserANY, SqlParserARRAY, SqlParserASC, SqlParserAT, SqlParserBERNOULLI, SqlParserCALL, SqlParserCASCADE, SqlParserCATALOGS, SqlParserCOALESCE, SqlParserCOLUMN, SqlParserCOLUMNS, SqlParserCOMMENT, SqlParserCOMMIT, SqlParserCOMMITTED, SqlParserCURRENT, SqlParserDATA, SqlParserDATE, SqlParserDAY, SqlParserDESC, SqlParserDISTRIBUTED, SqlParserEXCLUDING, SqlParserEXPLAIN, SqlParserFILTER, SqlParserFIRST, SqlParserFOLLOWING, SqlParserFORMAT, SqlParserFUNCTIONS, SqlParserGRANT, SqlParserGRANTS, SqlParserGRAPHVIZ, SqlParserHOUR, SqlParserIF, SqlParserINCLUDING, SqlParserINPUT, SqlParserINTEGER, SqlParserINTERVAL, SqlParserISOLATION, SqlParserLAST, SqlParserLATERAL, SqlParserLEVEL, SqlParserLIMIT, SqlParserLOGICAL, SqlParserMAP, SqlParserMINUTE, SqlParserMONTH, SqlParserNFC, SqlParserNFD, SqlParserNFKC, SqlParserNFKD, SqlParserNO, SqlParserNULLIF, SqlParserNULLS, SqlParserONLY, SqlParserOPTION, SqlParserORDINALITY, SqlParserOUTPUT, SqlParserOVER, SqlParserPARTITION, SqlParserPARTITIONS, SqlParserPOSITION, SqlParserPRECEDING, SqlParserPRIVILEGES, SqlParserPROPERTIES, SqlParserPUBLIC, SqlParserRANGE, SqlParserREAD, SqlParserRENAME, SqlParserREPEATABLE, SqlParserREPLACE, SqlParserRESET, SqlParserRESTRICT, SqlParserREVOKE, SqlParserROLLBACK, SqlParserROW, SqlParserROWS, SqlParserSCHEMA, SqlParserSCHEMAS, SqlParserSECOND, SqlParserSERIALIZABLE, SqlParserSESSION, SqlParserSET, SqlParserSETS, SqlParserSHOW, SqlParserSMALLINT, SqlParserSOME, SqlParserSTART, SqlParserSTATS, SqlParserSUBSTRING, SqlParserSYSTEM, SqlParserTABLES, SqlParserTABLESAMPLE, SqlParserTEXT, SqlParserTIME, SqlParserTIMESTAMP, SqlParserTINYINT, SqlParserTO, SqlParserTRANSACTION, SqlParserTRY_CAST, SqlParserTYPE, SqlParserUNBOUNDED, SqlParserUNCOMMITTED, SqlParserUSE, SqlParserVALIDATE, SqlParserVERBOSE, SqlParserVIEW, SqlParserWORK, SqlParserWRITE, SqlParserYEAR, SqlParserZONE, SqlParserIDENTIFIER, SqlParserDIGIT_IDENTIFIER, SqlParserQUOTED_IDENTIFIER, SqlParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(118)
			p.ColumnDefinition()
		}

	case SqlParserLIKE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(119)
			p.LikeClause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IColumnDefinitionContext is an interface to support dynamic dispatch.
type IColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnDefinitionContext differentiates from other interfaces.
	IsColumnDefinitionContext()
}

type ColumnDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefinitionContext() *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_columnDefinition
	return p
}

func (*ColumnDefinitionContext) IsColumnDefinitionContext() {}

func NewColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_columnDefinition

	return p
}

func (s *ColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnDefinitionContext) TypeSql() ITypeSqlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeSqlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeSqlContext)
}

func (s *ColumnDefinitionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlParserCOMMENT, 0)
}

func (s *ColumnDefinitionContext) StringSql() IStringSqlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringSqlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringSqlContext)
}

func (s *ColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitColumnDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) ColumnDefinition() (localctx IColumnDefinitionContext) {
	localctx = NewColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SqlParserRULE_columnDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(122)
		p.Identifier()
	}
	{
		p.SetState(123)
		p.typeSql(0)
	}
	p.SetState(126)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlParserCOMMENT {
		{
			p.SetState(124)
			p.Match(SqlParserCOMMENT)
		}
		{
			p.SetState(125)
			p.StringSql()
		}

	}

	return localctx
}

// ILikeClauseContext is an interface to support dynamic dispatch.
type ILikeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOptionType returns the optionType token.
	GetOptionType() antlr.Token

	// SetOptionType sets the optionType token.
	SetOptionType(antlr.Token)

	// IsLikeClauseContext differentiates from other interfaces.
	IsLikeClauseContext()
}

type LikeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	optionType antlr.Token
}

func NewEmptyLikeClauseContext() *LikeClauseContext {
	var p = new(LikeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_likeClause
	return p
}

func (*LikeClauseContext) IsLikeClauseContext() {}

func NewLikeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LikeClauseContext {
	var p = new(LikeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_likeClause

	return p
}

func (s *LikeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LikeClauseContext) GetOptionType() antlr.Token { return s.optionType }

func (s *LikeClauseContext) SetOptionType(v antlr.Token) { s.optionType = v }

func (s *LikeClauseContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlParserLIKE, 0)
}

func (s *LikeClauseContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *LikeClauseContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlParserPROPERTIES, 0)
}

func (s *LikeClauseContext) INCLUDING() antlr.TerminalNode {
	return s.GetToken(SqlParserINCLUDING, 0)
}

func (s *LikeClauseContext) EXCLUDING() antlr.TerminalNode {
	return s.GetToken(SqlParserEXCLUDING, 0)
}

func (s *LikeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LikeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterLikeClause(s)
	}
}

func (s *LikeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitLikeClause(s)
	}
}

func (s *LikeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitLikeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) LikeClause() (localctx ILikeClauseContext) {
	localctx = NewLikeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SqlParserRULE_likeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(128)
		p.Match(SqlParserLIKE)
	}
	{
		p.SetState(129)
		p.QualifiedName()
	}
	p.SetState(132)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlParserEXCLUDING || _la == SqlParserINCLUDING {
		{
			p.SetState(130)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LikeClauseContext).optionType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlParserEXCLUDING || _la == SqlParserINCLUDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LikeClauseContext).optionType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(131)
			p.Match(SqlParserPROPERTIES)
		}

	}

	return localctx
}

// IPropertiesContext is an interface to support dynamic dispatch.
type IPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertiesContext differentiates from other interfaces.
	IsPropertiesContext()
}

type PropertiesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertiesContext() *PropertiesContext {
	var p = new(PropertiesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_properties
	return p
}

func (*PropertiesContext) IsPropertiesContext() {}

func NewPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertiesContext {
	var p = new(PropertiesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_properties

	return p
}

func (s *PropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertiesContext) AllProperty() []IPropertyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPropertyContext)(nil)).Elem())
	var tst = make([]IPropertyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPropertyContext)
		}
	}

	return tst
}

func (s *PropertiesContext) Property(i int) IPropertyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *PropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterProperties(s)
	}
}

func (s *PropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitProperties(s)
	}
}

func (s *PropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) Properties() (localctx IPropertiesContext) {
	localctx = NewPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SqlParserRULE_properties)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(134)
		p.Match(SqlParserT__1)
	}
	{
		p.SetState(135)
		p.Property()
	}
	p.SetState(140)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SqlParserT__0 {
		{
			p.SetState(136)
			p.Match(SqlParserT__0)
		}
		{
			p.SetState(137)
			p.Property()
		}

		p.SetState(142)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(143)
		p.Match(SqlParserT__2)
	}

	return localctx
}

// IPropertyContext is an interface to support dynamic dispatch.
type IPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyContext differentiates from other interfaces.
	IsPropertyContext()
}

type PropertyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyContext() *PropertyContext {
	var p = new(PropertyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_property
	return p
}

func (*PropertyContext) IsPropertyContext() {}

func NewPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyContext {
	var p = new(PropertyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_property

	return p
}

func (s *PropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlParserEQ, 0)
}

func (s *PropertyContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterProperty(s)
	}
}

func (s *PropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitProperty(s)
	}
}

func (s *PropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) Property() (localctx IPropertyContext) {
	localctx = NewPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SqlParserRULE_property)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(145)
		p.Identifier()
	}
	{
		p.SetState(146)
		p.Match(SqlParserEQ)
	}
	{
		p.SetState(147)
		p.Expression()
	}

	return localctx
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  antlr.Token
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_query
	return p
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) GetLimit() antlr.Token { return s.limit }

func (s *QueryContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *QueryContext) QueryTerm() IQueryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryTermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *QueryContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SqlParserORDER, 0)
}

func (s *QueryContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlParserBY, 0)
}

func (s *QueryContext) AllSortItem() []ISortItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortItemContext)(nil)).Elem())
	var tst = make([]ISortItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortItemContext)
		}
	}

	return tst
}

func (s *QueryContext) SortItem(i int) ISortItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *QueryContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SqlParserLIMIT, 0)
}

func (s *QueryContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlParserINTEGER_VALUE, 0)
}

func (s *QueryContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlParserALL, 0)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (s *QueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SqlParserRULE_query)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(149)
		p.queryTerm(0)
	}
	p.SetState(160)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlParserORDER {
		{
			p.SetState(150)
			p.Match(SqlParserORDER)
		}
		{
			p.SetState(151)
			p.Match(SqlParserBY)
		}
		{
			p.SetState(152)
			p.SortItem()
		}
		p.SetState(157)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlParserT__0 {
			{
				p.SetState(153)
				p.Match(SqlParserT__0)
			}
			{
				p.SetState(154)
				p.SortItem()
			}

			p.SetState(159)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(164)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlParserLIMIT {
		{
			p.SetState(162)
			p.Match(SqlParserLIMIT)
		}
		{
			p.SetState(163)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*QueryContext).limit = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlParserALL || _la == SqlParserINTEGER_VALUE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*QueryContext).limit = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IQueryTermContext is an interface to support dynamic dispatch.
type IQueryTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryTermContext differentiates from other interfaces.
	IsQueryTermContext()
}

type QueryTermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryTermContext() *QueryTermContext {
	var p = new(QueryTermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_queryTerm
	return p
}

func (*QueryTermContext) IsQueryTermContext() {}

func NewQueryTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryTermContext {
	var p = new(QueryTermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_queryTerm

	return p
}

func (s *QueryTermContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryTermContext) CopyFrom(ctx *QueryTermContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *QueryTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QueryTermDefaultContext struct {
	*QueryTermContext
}

func NewQueryTermDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryTermDefaultContext {
	var p = new(QueryTermDefaultContext)

	p.QueryTermContext = NewEmptyQueryTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryTermContext))

	return p
}

func (s *QueryTermDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermDefaultContext) QueryPrimary() IQueryPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *QueryTermDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterQueryTermDefault(s)
	}
}

func (s *QueryTermDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitQueryTermDefault(s)
	}
}

func (s *QueryTermDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitQueryTermDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetOperationContext struct {
	*QueryTermContext
	left     IQueryTermContext
	operator antlr.Token
	right    IQueryTermContext
}

func NewSetOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetOperationContext {
	var p = new(SetOperationContext)

	p.QueryTermContext = NewEmptyQueryTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryTermContext))

	return p
}

func (s *SetOperationContext) GetOperator() antlr.Token { return s.operator }

func (s *SetOperationContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *SetOperationContext) GetLeft() IQueryTermContext { return s.left }

func (s *SetOperationContext) GetRight() IQueryTermContext { return s.right }

func (s *SetOperationContext) SetLeft(v IQueryTermContext) { s.left = v }

func (s *SetOperationContext) SetRight(v IQueryTermContext) { s.right = v }

func (s *SetOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOperationContext) AllQueryTerm() []IQueryTermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQueryTermContext)(nil)).Elem())
	var tst = make([]IQueryTermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQueryTermContext)
		}
	}

	return tst
}

func (s *SetOperationContext) QueryTerm(i int) IQueryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryTermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *SetOperationContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(SqlParserINTERSECT, 0)
}

func (s *SetOperationContext) SetQuantifier() ISetQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *SetOperationContext) UNION() antlr.TerminalNode {
	return s.GetToken(SqlParserUNION, 0)
}

func (s *SetOperationContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(SqlParserEXCEPT, 0)
}

func (s *SetOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterSetOperation(s)
	}
}

func (s *SetOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitSetOperation(s)
	}
}

func (s *SetOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitSetOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) QueryTerm() (localctx IQueryTermContext) {
	return p.queryTerm(0)
}

func (p *SqlParser) queryTerm(_p int) (localctx IQueryTermContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewQueryTermContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQueryTermContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 20
	p.EnterRecursionRule(localctx, 20, SqlParserRULE_queryTerm, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewQueryTermDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(167)
		p.QueryPrimary()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(183)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(181)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlParserRULE_queryTerm)
				p.SetState(169)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(170)

					var _m = p.Match(SqlParserINTERSECT)

					localctx.(*SetOperationContext).operator = _m
				}
				p.SetState(172)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == SqlParserALL || _la == SqlParserDISTINCT {
					{
						p.SetState(171)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(174)

					var _x = p.queryTerm(3)

					localctx.(*SetOperationContext).right = _x
				}

			case 2:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlParserRULE_queryTerm)
				p.SetState(175)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(176)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*SetOperationContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == SqlParserEXCEPT || _la == SqlParserUNION) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*SetOperationContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(178)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == SqlParserALL || _la == SqlParserDISTINCT {
					{
						p.SetState(177)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(180)

					var _x = p.queryTerm(2)

					localctx.(*SetOperationContext).right = _x
				}

			}

		}
		p.SetState(185)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())
	}

	return localctx
}

// IQueryPrimaryContext is an interface to support dynamic dispatch.
type IQueryPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryPrimaryContext differentiates from other interfaces.
	IsQueryPrimaryContext()
}

type QueryPrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryPrimaryContext() *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_queryPrimary
	return p
}

func (*QueryPrimaryContext) IsQueryPrimaryContext() {}

func NewQueryPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_queryPrimary

	return p
}

func (s *QueryPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPrimaryContext) CopyFrom(ctx *QueryPrimaryContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *QueryPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryContext struct {
	*QueryPrimaryContext
}

func NewSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryContext {
	var p = new(SubqueryContext)

	p.QueryPrimaryContext = NewEmptyQueryPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryPrimaryContext))

	return p
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitSubquery(s)
	}
}

func (s *SubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

type QueryPrimaryDefaultContext struct {
	*QueryPrimaryContext
}

func NewQueryPrimaryDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryPrimaryDefaultContext {
	var p = new(QueryPrimaryDefaultContext)

	p.QueryPrimaryContext = NewEmptyQueryPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryPrimaryContext))

	return p
}

func (s *QueryPrimaryDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryDefaultContext) QuerySpecification() IQuerySpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuerySpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryPrimaryDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitQueryPrimaryDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableContext struct {
	*QueryPrimaryContext
}

func NewTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableContext {
	var p = new(TableContext)

	p.QueryPrimaryContext = NewEmptyQueryPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryPrimaryContext))

	return p
}

func (s *TableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlParserTABLE, 0)
}

func (s *TableContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterTable(s)
	}
}

func (s *TableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitTable(s)
	}
}

func (s *TableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type InlineTableContext struct {
	*QueryPrimaryContext
}

func NewInlineTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InlineTableContext {
	var p = new(InlineTableContext)

	p.QueryPrimaryContext = NewEmptyQueryPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryPrimaryContext))

	return p
}

func (s *InlineTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineTableContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SqlParserVALUES, 0)
}

func (s *InlineTableContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *InlineTableContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InlineTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterInlineTable(s)
	}
}

func (s *InlineTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitInlineTable(s)
	}
}

func (s *InlineTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitInlineTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) QueryPrimary() (localctx IQueryPrimaryContext) {
	localctx = NewQueryPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SqlParserRULE_queryPrimary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(202)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlParserSELECT:
		localctx = NewQueryPrimaryDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(186)
			p.QuerySpecification()
		}

	case SqlParserTABLE:
		localctx = NewTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(187)
			p.Match(SqlParserTABLE)
		}
		{
			p.SetState(188)
			p.QualifiedName()
		}

	case SqlParserVALUES:
		localctx = NewInlineTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(189)
			p.Match(SqlParserVALUES)
		}
		{
			p.SetState(190)
			p.Expression()
		}
		p.SetState(195)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(191)
					p.Match(SqlParserT__0)
				}
				{
					p.SetState(192)
					p.Expression()
				}

			}
			p.SetState(197)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext())
		}

	case SqlParserT__1:
		localctx = NewSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(198)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(199)
			p.Query()
		}
		{
			p.SetState(200)
			p.Match(SqlParserT__2)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrdering returns the ordering token.
	GetOrdering() antlr.Token

	// GetNullOrdering returns the nullOrdering token.
	GetNullOrdering() antlr.Token

	// SetOrdering sets the ordering token.
	SetOrdering(antlr.Token)

	// SetNullOrdering sets the nullOrdering token.
	SetNullOrdering(antlr.Token)

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	ordering     antlr.Token
	nullOrdering antlr.Token
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_sortItem
	return p
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) GetOrdering() antlr.Token { return s.ordering }

func (s *SortItemContext) GetNullOrdering() antlr.Token { return s.nullOrdering }

func (s *SortItemContext) SetOrdering(v antlr.Token) { s.ordering = v }

func (s *SortItemContext) SetNullOrdering(v antlr.Token) { s.nullOrdering = v }

func (s *SortItemContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SortItemContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SqlParserNULLS, 0)
}

func (s *SortItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(SqlParserASC, 0)
}

func (s *SortItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlParserDESC, 0)
}

func (s *SortItemContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SqlParserFIRST, 0)
}

func (s *SortItemContext) LAST() antlr.TerminalNode {
	return s.GetToken(SqlParserLAST, 0)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterSortItem(s)
	}
}

func (s *SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitSortItem(s)
	}
}

func (s *SortItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitSortItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) SortItem() (localctx ISortItemContext) {
	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SqlParserRULE_sortItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(204)
		p.Expression()
	}
	p.SetState(206)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlParserASC || _la == SqlParserDESC {
		{
			p.SetState(205)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).ordering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlParserASC || _la == SqlParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).ordering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(210)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlParserNULLS {
		{
			p.SetState(208)
			p.Match(SqlParserNULLS)
		}
		{
			p.SetState(209)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).nullOrdering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlParserFIRST || _la == SqlParserLAST) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).nullOrdering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IBooleanExpressionContext

	// GetHaving returns the having rule contexts.
	GetHaving() IBooleanExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IBooleanExpressionContext)

	// SetHaving sets the having rule contexts.
	SetHaving(IBooleanExpressionContext)

	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IBooleanExpressionContext
	having IBooleanExpressionContext
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_querySpecification
	return p
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) GetWhere() IBooleanExpressionContext { return s.where }

func (s *QuerySpecificationContext) GetHaving() IBooleanExpressionContext { return s.having }

func (s *QuerySpecificationContext) SetWhere(v IBooleanExpressionContext) { s.where = v }

func (s *QuerySpecificationContext) SetHaving(v IBooleanExpressionContext) { s.having = v }

func (s *QuerySpecificationContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SqlParserSELECT, 0)
}

func (s *QuerySpecificationContext) AllSelectItem() []ISelectItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectItemContext)(nil)).Elem())
	var tst = make([]ISelectItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectItemContext)
		}
	}

	return tst
}

func (s *QuerySpecificationContext) SelectItem(i int) ISelectItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *QuerySpecificationContext) SetQuantifier() ISetQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *QuerySpecificationContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlParserFROM, 0)
}

func (s *QuerySpecificationContext) AllRelation() []IRelationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelationContext)(nil)).Elem())
	var tst = make([]IRelationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelationContext)
		}
	}

	return tst
}

func (s *QuerySpecificationContext) Relation(i int) IRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *QuerySpecificationContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlParserWHERE, 0)
}

func (s *QuerySpecificationContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SqlParserGROUP, 0)
}

func (s *QuerySpecificationContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlParserBY, 0)
}

func (s *QuerySpecificationContext) GroupBy() IGroupByContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupByContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupByContext)
}

func (s *QuerySpecificationContext) HAVING() antlr.TerminalNode {
	return s.GetToken(SqlParserHAVING, 0)
}

func (s *QuerySpecificationContext) AllBooleanExpression() []IBooleanExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem())
	var tst = make([]IBooleanExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBooleanExpressionContext)
		}
	}

	return tst
}

func (s *QuerySpecificationContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitQuerySpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SqlParserRULE_querySpecification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(212)
		p.Match(SqlParserSELECT)
	}
	p.SetState(214)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(213)
			p.SetQuantifier()
		}

	}
	{
		p.SetState(216)
		p.SelectItem()
	}
	p.SetState(221)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(217)
				p.Match(SqlParserT__0)
			}
			{
				p.SetState(218)
				p.SelectItem()
			}

		}
		p.SetState(223)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())
	}
	p.SetState(233)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(224)
			p.Match(SqlParserFROM)
		}
		{
			p.SetState(225)
			p.relation(0)
		}
		p.SetState(230)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(226)
					p.Match(SqlParserT__0)
				}
				{
					p.SetState(227)
					p.relation(0)
				}

			}
			p.SetState(232)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())
		}

	}
	p.SetState(237)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(235)
			p.Match(SqlParserWHERE)
		}
		{
			p.SetState(236)

			var _x = p.booleanExpression(0)

			localctx.(*QuerySpecificationContext).where = _x
		}

	}
	p.SetState(242)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(239)
			p.Match(SqlParserGROUP)
		}
		{
			p.SetState(240)
			p.Match(SqlParserBY)
		}
		{
			p.SetState(241)
			p.GroupBy()
		}

	}
	p.SetState(246)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(244)
			p.Match(SqlParserHAVING)
		}
		{
			p.SetState(245)

			var _x = p.booleanExpression(0)

			localctx.(*QuerySpecificationContext).having = _x
		}

	}

	return localctx
}

// IGroupByContext is an interface to support dynamic dispatch.
type IGroupByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupByContext differentiates from other interfaces.
	IsGroupByContext()
}

type GroupByContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByContext() *GroupByContext {
	var p = new(GroupByContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_groupBy
	return p
}

func (*GroupByContext) IsGroupByContext() {}

func NewGroupByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByContext {
	var p = new(GroupByContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_groupBy

	return p
}

func (s *GroupByContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByContext) AllGroupingElement() []IGroupingElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGroupingElementContext)(nil)).Elem())
	var tst = make([]IGroupingElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGroupingElementContext)
		}
	}

	return tst
}

func (s *GroupByContext) GroupingElement(i int) IGroupingElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupingElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGroupingElementContext)
}

func (s *GroupByContext) SetQuantifier() ISetQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *GroupByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterGroupBy(s)
	}
}

func (s *GroupByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitGroupBy(s)
	}
}

func (s *GroupByContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitGroupBy(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) GroupBy() (localctx IGroupByContext) {
	localctx = NewGroupByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SqlParserRULE_groupBy)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(249)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(248)
			p.SetQuantifier()
		}

	}
	{
		p.SetState(251)
		p.GroupingElement()
	}
	p.SetState(256)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(252)
				p.Match(SqlParserT__0)
			}
			{
				p.SetState(253)
				p.GroupingElement()
			}

		}
		p.SetState(258)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext())
	}

	return localctx
}

// IGroupingElementContext is an interface to support dynamic dispatch.
type IGroupingElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupingElementContext differentiates from other interfaces.
	IsGroupingElementContext()
}

type GroupingElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingElementContext() *GroupingElementContext {
	var p = new(GroupingElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_groupingElement
	return p
}

func (*GroupingElementContext) IsGroupingElementContext() {}

func NewGroupingElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingElementContext {
	var p = new(GroupingElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_groupingElement

	return p
}

func (s *GroupingElementContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingElementContext) CopyFrom(ctx *GroupingElementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *GroupingElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SingleGroupingSetContext struct {
	*GroupingElementContext
}

func NewSingleGroupingSetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SingleGroupingSetContext {
	var p = new(SingleGroupingSetContext)

	p.GroupingElementContext = NewEmptyGroupingElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GroupingElementContext))

	return p
}

func (s *SingleGroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleGroupingSetContext) GroupingExpressions() IGroupingExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupingExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupingExpressionsContext)
}

func (s *SingleGroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterSingleGroupingSet(s)
	}
}

func (s *SingleGroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitSingleGroupingSet(s)
	}
}

func (s *SingleGroupingSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitSingleGroupingSet(s)

	default:
		return t.VisitChildren(s)
	}
}

type CubeContext struct {
	*GroupingElementContext
}

func NewCubeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CubeContext {
	var p = new(CubeContext)

	p.GroupingElementContext = NewEmptyGroupingElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GroupingElementContext))

	return p
}

func (s *CubeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CubeContext) CUBE() antlr.TerminalNode {
	return s.GetToken(SqlParserCUBE, 0)
}

func (s *CubeContext) AllQualifiedName() []IQualifiedNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem())
	var tst = make([]IQualifiedNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedNameContext)
		}
	}

	return tst
}

func (s *CubeContext) QualifiedName(i int) IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CubeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterCube(s)
	}
}

func (s *CubeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitCube(s)
	}
}

func (s *CubeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitCube(s)

	default:
		return t.VisitChildren(s)
	}
}

type RollupContext struct {
	*GroupingElementContext
}

func NewRollupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RollupContext {
	var p = new(RollupContext)

	p.GroupingElementContext = NewEmptyGroupingElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GroupingElementContext))

	return p
}

func (s *RollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(SqlParserROLLUP, 0)
}

func (s *RollupContext) AllQualifiedName() []IQualifiedNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem())
	var tst = make([]IQualifiedNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedNameContext)
		}
	}

	return tst
}

func (s *RollupContext) QualifiedName(i int) IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterRollup(s)
	}
}

func (s *RollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitRollup(s)
	}
}

func (s *RollupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitRollup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) GroupingElement() (localctx IGroupingElementContext) {
	localctx = NewGroupingElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SqlParserRULE_groupingElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(286)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlParserT__1, SqlParserT__4, SqlParserADD, SqlParserALL, SqlParserANALYZE, SqlParserANY, SqlParserARRAY, SqlParserASC, SqlParserAT, SqlParserBERNOULLI, SqlParserCALL, SqlParserCASCADE, SqlParserCASE, SqlParserCAST, SqlParserCATALOGS, SqlParserCOALESCE, SqlParserCOLUMN, SqlParserCOLUMNS, SqlParserCOMMENT, SqlParserCOMMIT, SqlParserCOMMITTED, SqlParserCURRENT, SqlParserCURRENT_DATE, SqlParserCURRENT_TIME, SqlParserCURRENT_TIMESTAMP, SqlParserDATA, SqlParserDATE, SqlParserDAY, SqlParserDESC, SqlParserDISTRIBUTED, SqlParserEXCLUDING, SqlParserEXISTS, SqlParserEXPLAIN, SqlParserEXTRACT, SqlParserFALSE, SqlParserFILTER, SqlParserFIRST, SqlParserFOLLOWING, SqlParserFORMAT, SqlParserFUNCTIONS, SqlParserGRANT, SqlParserGRANTS, SqlParserGRAPHVIZ, SqlParserGROUPING, SqlParserHOUR, SqlParserIF, SqlParserINCLUDING, SqlParserINPUT, SqlParserINTEGER, SqlParserINTERVAL, SqlParserISOLATION, SqlParserLAST, SqlParserLATERAL, SqlParserLEVEL, SqlParserLIMIT, SqlParserLOCALTIME, SqlParserLOCALTIMESTAMP, SqlParserLOGICAL, SqlParserMAP, SqlParserMINUTE, SqlParserMONTH, SqlParserNFC, SqlParserNFD, SqlParserNFKC, SqlParserNFKD, SqlParserNO, SqlParserNOT, SqlParserNULL, SqlParserNULLIF, SqlParserNULLS, SqlParserONLY, SqlParserOPTION, SqlParserORDINALITY, SqlParserOUTPUT, SqlParserOVER, SqlParserPARTITION, SqlParserPARTITIONS, SqlParserPOSITION, SqlParserPRECEDING, SqlParserPRIVILEGES, SqlParserPROPERTIES, SqlParserPUBLIC, SqlParserRANGE, SqlParserREAD, SqlParserRENAME, SqlParserREPEATABLE, SqlParserREPLACE, SqlParserRESET, SqlParserRESTRICT, SqlParserREVOKE, SqlParserROLLBACK, SqlParserROW, SqlParserROWS, SqlParserSCHEMA, SqlParserSCHEMAS, SqlParserSECOND, SqlParserSERIALIZABLE, SqlParserSESSION, SqlParserSET, SqlParserSETS, SqlParserSHOW, SqlParserSMALLINT, SqlParserSOME, SqlParserSTART, SqlParserSTATS, SqlParserSUBSTRING, SqlParserSYSTEM, SqlParserTABLES, SqlParserTABLESAMPLE, SqlParserTEXT, SqlParserTIME, SqlParserTIMESTAMP, SqlParserTINYINT, SqlParserTO, SqlParserTRANSACTION, SqlParserTRUE, SqlParserTRY_CAST, SqlParserTYPE, SqlParserUNBOUNDED, SqlParserUNCOMMITTED, SqlParserUSE, SqlParserVALIDATE, SqlParserVERBOSE, SqlParserVIEW, SqlParserWORK, SqlParserWRITE, SqlParserYEAR, SqlParserZONE, SqlParserPLUS, SqlParserMINUS, SqlParserSTRING, SqlParserUNICODE_STRING, SqlParserBINARY_LITERAL, SqlParserINTEGER_VALUE, SqlParserDECIMAL_VALUE, SqlParserDOUBLE_VALUE, SqlParserIDENTIFIER, SqlParserDIGIT_IDENTIFIER, SqlParserQUOTED_IDENTIFIER, SqlParserBACKQUOTED_IDENTIFIER, SqlParserDOUBLE_PRECISION:
		localctx = NewSingleGroupingSetContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(259)
			p.GroupingExpressions()
		}

	case SqlParserROLLUP:
		localctx = NewRollupContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(260)
			p.Match(SqlParserROLLUP)
		}
		{
			p.SetState(261)
			p.Match(SqlParserT__1)
		}
		p.SetState(270)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlParserADD)|(1<<SqlParserALL)|(1<<SqlParserANALYZE)|(1<<SqlParserANY)|(1<<SqlParserARRAY)|(1<<SqlParserASC)|(1<<SqlParserAT)|(1<<SqlParserBERNOULLI)|(1<<SqlParserCALL)|(1<<SqlParserCASCADE)|(1<<SqlParserCATALOGS)|(1<<SqlParserCOALESCE)|(1<<SqlParserCOLUMN)|(1<<SqlParserCOLUMNS)|(1<<SqlParserCOMMENT)|(1<<SqlParserCOMMIT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlParserCOMMITTED-32))|(1<<(SqlParserCURRENT-32))|(1<<(SqlParserDATA-32))|(1<<(SqlParserDATE-32))|(1<<(SqlParserDAY-32))|(1<<(SqlParserDESC-32))|(1<<(SqlParserDISTRIBUTED-32))|(1<<(SqlParserEXCLUDING-32))|(1<<(SqlParserEXPLAIN-32))|(1<<(SqlParserFILTER-32))|(1<<(SqlParserFIRST-32))|(1<<(SqlParserFOLLOWING-32)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(SqlParserFORMAT-65))|(1<<(SqlParserFUNCTIONS-65))|(1<<(SqlParserGRANT-65))|(1<<(SqlParserGRANTS-65))|(1<<(SqlParserGRAPHVIZ-65))|(1<<(SqlParserHOUR-65))|(1<<(SqlParserIF-65))|(1<<(SqlParserINCLUDING-65))|(1<<(SqlParserINPUT-65))|(1<<(SqlParserINTEGER-65))|(1<<(SqlParserINTERVAL-65))|(1<<(SqlParserISOLATION-65))|(1<<(SqlParserLAST-65))|(1<<(SqlParserLATERAL-65))|(1<<(SqlParserLEVEL-65))|(1<<(SqlParserLIMIT-65)))) != 0) || (((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(SqlParserLOGICAL-97))|(1<<(SqlParserMAP-97))|(1<<(SqlParserMINUTE-97))|(1<<(SqlParserMONTH-97))|(1<<(SqlParserNFC-97))|(1<<(SqlParserNFD-97))|(1<<(SqlParserNFKC-97))|(1<<(SqlParserNFKD-97))|(1<<(SqlParserNO-97))|(1<<(SqlParserNULLIF-97))|(1<<(SqlParserNULLS-97))|(1<<(SqlParserONLY-97))|(1<<(SqlParserOPTION-97))|(1<<(SqlParserORDINALITY-97))|(1<<(SqlParserOUTPUT-97))|(1<<(SqlParserOVER-97))|(1<<(SqlParserPARTITION-97))|(1<<(SqlParserPARTITIONS-97))|(1<<(SqlParserPOSITION-97))|(1<<(SqlParserPRECEDING-97))|(1<<(SqlParserPRIVILEGES-97))|(1<<(SqlParserPROPERTIES-97))|(1<<(SqlParserPUBLIC-97)))) != 0) || (((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(SqlParserRANGE-129))|(1<<(SqlParserREAD-129))|(1<<(SqlParserRENAME-129))|(1<<(SqlParserREPEATABLE-129))|(1<<(SqlParserREPLACE-129))|(1<<(SqlParserRESET-129))|(1<<(SqlParserRESTRICT-129))|(1<<(SqlParserREVOKE-129))|(1<<(SqlParserROLLBACK-129))|(1<<(SqlParserROW-129))|(1<<(SqlParserROWS-129))|(1<<(SqlParserSCHEMA-129))|(1<<(SqlParserSCHEMAS-129))|(1<<(SqlParserSECOND-129))|(1<<(SqlParserSERIALIZABLE-129))|(1<<(SqlParserSESSION-129))|(1<<(SqlParserSET-129))|(1<<(SqlParserSETS-129))|(1<<(SqlParserSHOW-129))|(1<<(SqlParserSMALLINT-129))|(1<<(SqlParserSOME-129))|(1<<(SqlParserSTART-129))|(1<<(SqlParserSTATS-129))|(1<<(SqlParserSUBSTRING-129))|(1<<(SqlParserSYSTEM-129))|(1<<(SqlParserTABLES-129))|(1<<(SqlParserTABLESAMPLE-129)))) != 0) || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SqlParserTEXT-161))|(1<<(SqlParserTIME-161))|(1<<(SqlParserTIMESTAMP-161))|(1<<(SqlParserTINYINT-161))|(1<<(SqlParserTO-161))|(1<<(SqlParserTRANSACTION-161))|(1<<(SqlParserTRY_CAST-161))|(1<<(SqlParserTYPE-161))|(1<<(SqlParserUNBOUNDED-161))|(1<<(SqlParserUNCOMMITTED-161))|(1<<(SqlParserUSE-161))|(1<<(SqlParserVALIDATE-161))|(1<<(SqlParserVERBOSE-161))|(1<<(SqlParserVIEW-161))|(1<<(SqlParserWORK-161))|(1<<(SqlParserWRITE-161))|(1<<(SqlParserYEAR-161))|(1<<(SqlParserZONE-161)))) != 0) || (((_la-207)&-(0x1f+1)) == 0 && ((1<<uint((_la-207)))&((1<<(SqlParserIDENTIFIER-207))|(1<<(SqlParserDIGIT_IDENTIFIER-207))|(1<<(SqlParserQUOTED_IDENTIFIER-207))|(1<<(SqlParserBACKQUOTED_IDENTIFIER-207)))) != 0) {
			{
				p.SetState(262)
				p.QualifiedName()
			}
			p.SetState(267)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlParserT__0 {
				{
					p.SetState(263)
					p.Match(SqlParserT__0)
				}
				{
					p.SetState(264)
					p.QualifiedName()
				}

				p.SetState(269)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(272)
			p.Match(SqlParserT__2)
		}

	case SqlParserCUBE:
		localctx = NewCubeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(273)
			p.Match(SqlParserCUBE)
		}
		{
			p.SetState(274)
			p.Match(SqlParserT__1)
		}
		p.SetState(283)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlParserADD)|(1<<SqlParserALL)|(1<<SqlParserANALYZE)|(1<<SqlParserANY)|(1<<SqlParserARRAY)|(1<<SqlParserASC)|(1<<SqlParserAT)|(1<<SqlParserBERNOULLI)|(1<<SqlParserCALL)|(1<<SqlParserCASCADE)|(1<<SqlParserCATALOGS)|(1<<SqlParserCOALESCE)|(1<<SqlParserCOLUMN)|(1<<SqlParserCOLUMNS)|(1<<SqlParserCOMMENT)|(1<<SqlParserCOMMIT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlParserCOMMITTED-32))|(1<<(SqlParserCURRENT-32))|(1<<(SqlParserDATA-32))|(1<<(SqlParserDATE-32))|(1<<(SqlParserDAY-32))|(1<<(SqlParserDESC-32))|(1<<(SqlParserDISTRIBUTED-32))|(1<<(SqlParserEXCLUDING-32))|(1<<(SqlParserEXPLAIN-32))|(1<<(SqlParserFILTER-32))|(1<<(SqlParserFIRST-32))|(1<<(SqlParserFOLLOWING-32)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(SqlParserFORMAT-65))|(1<<(SqlParserFUNCTIONS-65))|(1<<(SqlParserGRANT-65))|(1<<(SqlParserGRANTS-65))|(1<<(SqlParserGRAPHVIZ-65))|(1<<(SqlParserHOUR-65))|(1<<(SqlParserIF-65))|(1<<(SqlParserINCLUDING-65))|(1<<(SqlParserINPUT-65))|(1<<(SqlParserINTEGER-65))|(1<<(SqlParserINTERVAL-65))|(1<<(SqlParserISOLATION-65))|(1<<(SqlParserLAST-65))|(1<<(SqlParserLATERAL-65))|(1<<(SqlParserLEVEL-65))|(1<<(SqlParserLIMIT-65)))) != 0) || (((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(SqlParserLOGICAL-97))|(1<<(SqlParserMAP-97))|(1<<(SqlParserMINUTE-97))|(1<<(SqlParserMONTH-97))|(1<<(SqlParserNFC-97))|(1<<(SqlParserNFD-97))|(1<<(SqlParserNFKC-97))|(1<<(SqlParserNFKD-97))|(1<<(SqlParserNO-97))|(1<<(SqlParserNULLIF-97))|(1<<(SqlParserNULLS-97))|(1<<(SqlParserONLY-97))|(1<<(SqlParserOPTION-97))|(1<<(SqlParserORDINALITY-97))|(1<<(SqlParserOUTPUT-97))|(1<<(SqlParserOVER-97))|(1<<(SqlParserPARTITION-97))|(1<<(SqlParserPARTITIONS-97))|(1<<(SqlParserPOSITION-97))|(1<<(SqlParserPRECEDING-97))|(1<<(SqlParserPRIVILEGES-97))|(1<<(SqlParserPROPERTIES-97))|(1<<(SqlParserPUBLIC-97)))) != 0) || (((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(SqlParserRANGE-129))|(1<<(SqlParserREAD-129))|(1<<(SqlParserRENAME-129))|(1<<(SqlParserREPEATABLE-129))|(1<<(SqlParserREPLACE-129))|(1<<(SqlParserRESET-129))|(1<<(SqlParserRESTRICT-129))|(1<<(SqlParserREVOKE-129))|(1<<(SqlParserROLLBACK-129))|(1<<(SqlParserROW-129))|(1<<(SqlParserROWS-129))|(1<<(SqlParserSCHEMA-129))|(1<<(SqlParserSCHEMAS-129))|(1<<(SqlParserSECOND-129))|(1<<(SqlParserSERIALIZABLE-129))|(1<<(SqlParserSESSION-129))|(1<<(SqlParserSET-129))|(1<<(SqlParserSETS-129))|(1<<(SqlParserSHOW-129))|(1<<(SqlParserSMALLINT-129))|(1<<(SqlParserSOME-129))|(1<<(SqlParserSTART-129))|(1<<(SqlParserSTATS-129))|(1<<(SqlParserSUBSTRING-129))|(1<<(SqlParserSYSTEM-129))|(1<<(SqlParserTABLES-129))|(1<<(SqlParserTABLESAMPLE-129)))) != 0) || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SqlParserTEXT-161))|(1<<(SqlParserTIME-161))|(1<<(SqlParserTIMESTAMP-161))|(1<<(SqlParserTINYINT-161))|(1<<(SqlParserTO-161))|(1<<(SqlParserTRANSACTION-161))|(1<<(SqlParserTRY_CAST-161))|(1<<(SqlParserTYPE-161))|(1<<(SqlParserUNBOUNDED-161))|(1<<(SqlParserUNCOMMITTED-161))|(1<<(SqlParserUSE-161))|(1<<(SqlParserVALIDATE-161))|(1<<(SqlParserVERBOSE-161))|(1<<(SqlParserVIEW-161))|(1<<(SqlParserWORK-161))|(1<<(SqlParserWRITE-161))|(1<<(SqlParserYEAR-161))|(1<<(SqlParserZONE-161)))) != 0) || (((_la-207)&-(0x1f+1)) == 0 && ((1<<uint((_la-207)))&((1<<(SqlParserIDENTIFIER-207))|(1<<(SqlParserDIGIT_IDENTIFIER-207))|(1<<(SqlParserQUOTED_IDENTIFIER-207))|(1<<(SqlParserBACKQUOTED_IDENTIFIER-207)))) != 0) {
			{
				p.SetState(275)
				p.QualifiedName()
			}
			p.SetState(280)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlParserT__0 {
				{
					p.SetState(276)
					p.Match(SqlParserT__0)
				}
				{
					p.SetState(277)
					p.QualifiedName()
				}

				p.SetState(282)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(285)
			p.Match(SqlParserT__2)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGroupingExpressionsContext is an interface to support dynamic dispatch.
type IGroupingExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupingExpressionsContext differentiates from other interfaces.
	IsGroupingExpressionsContext()
}

type GroupingExpressionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingExpressionsContext() *GroupingExpressionsContext {
	var p = new(GroupingExpressionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_groupingExpressions
	return p
}

func (*GroupingExpressionsContext) IsGroupingExpressionsContext() {}

func NewGroupingExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingExpressionsContext {
	var p = new(GroupingExpressionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_groupingExpressions

	return p
}

func (s *GroupingExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingExpressionsContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *GroupingExpressionsContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingExpressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterGroupingExpressions(s)
	}
}

func (s *GroupingExpressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitGroupingExpressions(s)
	}
}

func (s *GroupingExpressionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitGroupingExpressions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) GroupingExpressions() (localctx IGroupingExpressionsContext) {
	localctx = NewGroupingExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SqlParserRULE_groupingExpressions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(301)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(288)
			p.Match(SqlParserT__1)
		}
		p.SetState(297)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlParserT__1)|(1<<SqlParserT__4)|(1<<SqlParserADD)|(1<<SqlParserALL)|(1<<SqlParserANALYZE)|(1<<SqlParserANY)|(1<<SqlParserARRAY)|(1<<SqlParserASC)|(1<<SqlParserAT)|(1<<SqlParserBERNOULLI)|(1<<SqlParserCALL)|(1<<SqlParserCASCADE)|(1<<SqlParserCASE)|(1<<SqlParserCAST)|(1<<SqlParserCATALOGS)|(1<<SqlParserCOALESCE)|(1<<SqlParserCOLUMN)|(1<<SqlParserCOLUMNS)|(1<<SqlParserCOMMENT)|(1<<SqlParserCOMMIT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlParserCOMMITTED-32))|(1<<(SqlParserCURRENT-32))|(1<<(SqlParserCURRENT_DATE-32))|(1<<(SqlParserCURRENT_TIME-32))|(1<<(SqlParserCURRENT_TIMESTAMP-32))|(1<<(SqlParserDATA-32))|(1<<(SqlParserDATE-32))|(1<<(SqlParserDAY-32))|(1<<(SqlParserDESC-32))|(1<<(SqlParserDISTRIBUTED-32))|(1<<(SqlParserEXCLUDING-32))|(1<<(SqlParserEXISTS-32))|(1<<(SqlParserEXPLAIN-32))|(1<<(SqlParserEXTRACT-32))|(1<<(SqlParserFALSE-32))|(1<<(SqlParserFILTER-32))|(1<<(SqlParserFIRST-32))|(1<<(SqlParserFOLLOWING-32)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(SqlParserFORMAT-65))|(1<<(SqlParserFUNCTIONS-65))|(1<<(SqlParserGRANT-65))|(1<<(SqlParserGRANTS-65))|(1<<(SqlParserGRAPHVIZ-65))|(1<<(SqlParserGROUPING-65))|(1<<(SqlParserHOUR-65))|(1<<(SqlParserIF-65))|(1<<(SqlParserINCLUDING-65))|(1<<(SqlParserINPUT-65))|(1<<(SqlParserINTEGER-65))|(1<<(SqlParserINTERVAL-65))|(1<<(SqlParserISOLATION-65))|(1<<(SqlParserLAST-65))|(1<<(SqlParserLATERAL-65))|(1<<(SqlParserLEVEL-65))|(1<<(SqlParserLIMIT-65))|(1<<(SqlParserLOCALTIME-65))|(1<<(SqlParserLOCALTIMESTAMP-65)))) != 0) || (((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(SqlParserLOGICAL-97))|(1<<(SqlParserMAP-97))|(1<<(SqlParserMINUTE-97))|(1<<(SqlParserMONTH-97))|(1<<(SqlParserNFC-97))|(1<<(SqlParserNFD-97))|(1<<(SqlParserNFKC-97))|(1<<(SqlParserNFKD-97))|(1<<(SqlParserNO-97))|(1<<(SqlParserNOT-97))|(1<<(SqlParserNULL-97))|(1<<(SqlParserNULLIF-97))|(1<<(SqlParserNULLS-97))|(1<<(SqlParserONLY-97))|(1<<(SqlParserOPTION-97))|(1<<(SqlParserORDINALITY-97))|(1<<(SqlParserOUTPUT-97))|(1<<(SqlParserOVER-97))|(1<<(SqlParserPARTITION-97))|(1<<(SqlParserPARTITIONS-97))|(1<<(SqlParserPOSITION-97))|(1<<(SqlParserPRECEDING-97))|(1<<(SqlParserPRIVILEGES-97))|(1<<(SqlParserPROPERTIES-97))|(1<<(SqlParserPUBLIC-97)))) != 0) || (((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(SqlParserRANGE-129))|(1<<(SqlParserREAD-129))|(1<<(SqlParserRENAME-129))|(1<<(SqlParserREPEATABLE-129))|(1<<(SqlParserREPLACE-129))|(1<<(SqlParserRESET-129))|(1<<(SqlParserRESTRICT-129))|(1<<(SqlParserREVOKE-129))|(1<<(SqlParserROLLBACK-129))|(1<<(SqlParserROW-129))|(1<<(SqlParserROWS-129))|(1<<(SqlParserSCHEMA-129))|(1<<(SqlParserSCHEMAS-129))|(1<<(SqlParserSECOND-129))|(1<<(SqlParserSERIALIZABLE-129))|(1<<(SqlParserSESSION-129))|(1<<(SqlParserSET-129))|(1<<(SqlParserSETS-129))|(1<<(SqlParserSHOW-129))|(1<<(SqlParserSMALLINT-129))|(1<<(SqlParserSOME-129))|(1<<(SqlParserSTART-129))|(1<<(SqlParserSTATS-129))|(1<<(SqlParserSUBSTRING-129))|(1<<(SqlParserSYSTEM-129))|(1<<(SqlParserTABLES-129))|(1<<(SqlParserTABLESAMPLE-129)))) != 0) || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SqlParserTEXT-161))|(1<<(SqlParserTIME-161))|(1<<(SqlParserTIMESTAMP-161))|(1<<(SqlParserTINYINT-161))|(1<<(SqlParserTO-161))|(1<<(SqlParserTRANSACTION-161))|(1<<(SqlParserTRUE-161))|(1<<(SqlParserTRY_CAST-161))|(1<<(SqlParserTYPE-161))|(1<<(SqlParserUNBOUNDED-161))|(1<<(SqlParserUNCOMMITTED-161))|(1<<(SqlParserUSE-161))|(1<<(SqlParserVALIDATE-161))|(1<<(SqlParserVERBOSE-161))|(1<<(SqlParserVIEW-161))|(1<<(SqlParserWORK-161))|(1<<(SqlParserWRITE-161))|(1<<(SqlParserYEAR-161))|(1<<(SqlParserZONE-161)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SqlParserPLUS-195))|(1<<(SqlParserMINUS-195))|(1<<(SqlParserSTRING-195))|(1<<(SqlParserUNICODE_STRING-195))|(1<<(SqlParserBINARY_LITERAL-195))|(1<<(SqlParserINTEGER_VALUE-195))|(1<<(SqlParserDECIMAL_VALUE-195))|(1<<(SqlParserDOUBLE_VALUE-195))|(1<<(SqlParserIDENTIFIER-195))|(1<<(SqlParserDIGIT_IDENTIFIER-195))|(1<<(SqlParserQUOTED_IDENTIFIER-195))|(1<<(SqlParserBACKQUOTED_IDENTIFIER-195))|(1<<(SqlParserDOUBLE_PRECISION-195)))) != 0) {
			{
				p.SetState(289)
				p.Expression()
			}
			p.SetState(294)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlParserT__0 {
				{
					p.SetState(290)
					p.Match(SqlParserT__0)
				}
				{
					p.SetState(291)
					p.Expression()
				}

				p.SetState(296)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(299)
			p.Match(SqlParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(300)
			p.Expression()
		}

	}

	return localctx
}

// INamedQueryContext is an interface to support dynamic dispatch.
type INamedQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// IsNamedQueryContext differentiates from other interfaces.
	IsNamedQueryContext()
}

type NamedQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyNamedQueryContext() *NamedQueryContext {
	var p = new(NamedQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_namedQuery
	return p
}

func (*NamedQueryContext) IsNamedQueryContext() {}

func NewNamedQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedQueryContext {
	var p = new(NamedQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_namedQuery

	return p
}

func (s *NamedQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedQueryContext) GetName() IIdentifierContext { return s.name }

func (s *NamedQueryContext) SetName(v IIdentifierContext) { s.name = v }

func (s *NamedQueryContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlParserAS, 0)
}

func (s *NamedQueryContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *NamedQueryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedQueryContext) ColumnAliases() IColumnAliasesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnAliasesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *NamedQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterNamedQuery(s)
	}
}

func (s *NamedQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitNamedQuery(s)
	}
}

func (s *NamedQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitNamedQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) NamedQuery() (localctx INamedQueryContext) {
	localctx = NewNamedQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SqlParserRULE_namedQuery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(303)

		var _x = p.Identifier()

		localctx.(*NamedQueryContext).name = _x
	}
	p.SetState(305)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlParserT__1 {
		{
			p.SetState(304)
			p.ColumnAliases()
		}

	}
	{
		p.SetState(307)
		p.Match(SqlParserAS)
	}
	{
		p.SetState(308)
		p.Match(SqlParserT__1)
	}
	{
		p.SetState(309)
		p.Query()
	}
	{
		p.SetState(310)
		p.Match(SqlParserT__2)
	}

	return localctx
}

// ISetQuantifierContext is an interface to support dynamic dispatch.
type ISetQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetQuantifierContext differentiates from other interfaces.
	IsSetQuantifierContext()
}

type SetQuantifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetQuantifierContext() *SetQuantifierContext {
	var p = new(SetQuantifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_setQuantifier
	return p
}

func (*SetQuantifierContext) IsSetQuantifierContext() {}

func NewSetQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetQuantifierContext {
	var p = new(SetQuantifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_setQuantifier

	return p
}

func (s *SetQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SetQuantifierContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SqlParserDISTINCT, 0)
}

func (s *SetQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlParserALL, 0)
}

func (s *SetQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitSetQuantifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) SetQuantifier() (localctx ISetQuantifierContext) {
	localctx = NewSetQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SqlParserRULE_setQuantifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(312)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlParserALL || _la == SqlParserDISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISelectItemContext is an interface to support dynamic dispatch.
type ISelectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectItemContext differentiates from other interfaces.
	IsSelectItemContext()
}

type SelectItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemContext() *SelectItemContext {
	var p = new(SelectItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_selectItem
	return p
}

func (*SelectItemContext) IsSelectItemContext() {}

func NewSelectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemContext {
	var p = new(SelectItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_selectItem

	return p
}

func (s *SelectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemContext) CopyFrom(ctx *SelectItemContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SelectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectAllContext struct {
	*SelectItemContext
}

func NewSelectAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectAllContext {
	var p = new(SelectAllContext)

	p.SelectItemContext = NewEmptySelectItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectItemContext))

	return p
}

func (s *SelectAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectAllContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SelectAllContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlParserASTERISK, 0)
}

func (s *SelectAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterSelectAll(s)
	}
}

func (s *SelectAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitSelectAll(s)
	}
}

func (s *SelectAllContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitSelectAll(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectSingleContext struct {
	*SelectItemContext
}

func NewSelectSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectSingleContext {
	var p = new(SelectSingleContext)

	p.SelectItemContext = NewEmptySelectItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectItemContext))

	return p
}

func (s *SelectSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSingleContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectSingleContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectSingleContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlParserAS, 0)
}

func (s *SelectSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterSelectSingle(s)
	}
}

func (s *SelectSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitSelectSingle(s)
	}
}

func (s *SelectSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitSelectSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) SelectItem() (localctx ISelectItemContext) {
	localctx = NewSelectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SqlParserRULE_selectItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(326)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(314)
			p.Expression()
		}
		p.SetState(319)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
			p.SetState(316)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlParserAS {
				{
					p.SetState(315)
					p.Match(SqlParserAS)
				}

			}
			{
				p.SetState(318)
				p.Identifier()
			}

		}

	case 2:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(321)
			p.QualifiedName()
		}
		{
			p.SetState(322)
			p.Match(SqlParserT__3)
		}
		{
			p.SetState(323)
			p.Match(SqlParserASTERISK)
		}

	case 3:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(325)
			p.Match(SqlParserASTERISK)
		}

	}

	return localctx
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_relation
	return p
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) CopyFrom(ctx *RelationContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RelationDefaultContext struct {
	*RelationContext
}

func NewRelationDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationDefaultContext {
	var p = new(RelationDefaultContext)

	p.RelationContext = NewEmptyRelationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationContext))

	return p
}

func (s *RelationDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationDefaultContext) SampledRelation() ISampledRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISampledRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISampledRelationContext)
}

func (s *RelationDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterRelationDefault(s)
	}
}

func (s *RelationDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitRelationDefault(s)
	}
}

func (s *RelationDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitRelationDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type JoinRelationContext struct {
	*RelationContext
	left          IRelationContext
	right         ISampledRelationContext
	rightRelation IRelationContext
}

func NewJoinRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinRelationContext {
	var p = new(JoinRelationContext)

	p.RelationContext = NewEmptyRelationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationContext))

	return p
}

func (s *JoinRelationContext) GetLeft() IRelationContext { return s.left }

func (s *JoinRelationContext) GetRight() ISampledRelationContext { return s.right }

func (s *JoinRelationContext) GetRightRelation() IRelationContext { return s.rightRelation }

func (s *JoinRelationContext) SetLeft(v IRelationContext) { s.left = v }

func (s *JoinRelationContext) SetRight(v ISampledRelationContext) { s.right = v }

func (s *JoinRelationContext) SetRightRelation(v IRelationContext) { s.rightRelation = v }

func (s *JoinRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinRelationContext) AllRelation() []IRelationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelationContext)(nil)).Elem())
	var tst = make([]IRelationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelationContext)
		}
	}

	return tst
}

func (s *JoinRelationContext) Relation(i int) IRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *JoinRelationContext) CROSS() antlr.TerminalNode {
	return s.GetToken(SqlParserCROSS, 0)
}

func (s *JoinRelationContext) JOIN() antlr.TerminalNode {
	return s.GetToken(SqlParserJOIN, 0)
}

func (s *JoinRelationContext) JoinType() IJoinTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinTypeContext)
}

func (s *JoinRelationContext) JoinCriteria() IJoinCriteriaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinCriteriaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinCriteriaContext)
}

func (s *JoinRelationContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(SqlParserNATURAL, 0)
}

func (s *JoinRelationContext) SampledRelation() ISampledRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISampledRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISampledRelationContext)
}

func (s *JoinRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterJoinRelation(s)
	}
}

func (s *JoinRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitJoinRelation(s)
	}
}

func (s *JoinRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitJoinRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) Relation() (localctx IRelationContext) {
	return p.relation(0)
}

func (p *SqlParser) relation(_p int) (localctx IRelationContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRelationContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRelationContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 40
	p.EnterRecursionRule(localctx, 40, SqlParserRULE_relation, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewRelationDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(329)
		p.SampledRelation()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(349)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewJoinRelationContext(p, NewRelationContext(p, _parentctx, _parentState))
			localctx.(*JoinRelationContext).left = _prevctx

			p.PushNewRecursionContext(localctx, _startState, SqlParserRULE_relation)
			p.SetState(331)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			p.SetState(345)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SqlParserCROSS:
				{
					p.SetState(332)
					p.Match(SqlParserCROSS)
				}
				{
					p.SetState(333)
					p.Match(SqlParserJOIN)
				}
				{
					p.SetState(334)

					var _x = p.SampledRelation()

					localctx.(*JoinRelationContext).right = _x
				}

			case SqlParserFULL, SqlParserINNER, SqlParserJOIN, SqlParserLEFT, SqlParserRIGHT:
				{
					p.SetState(335)
					p.JoinType()
				}
				{
					p.SetState(336)
					p.Match(SqlParserJOIN)
				}
				{
					p.SetState(337)

					var _x = p.relation(0)

					localctx.(*JoinRelationContext).rightRelation = _x
				}
				{
					p.SetState(338)
					p.JoinCriteria()
				}

			case SqlParserNATURAL:
				{
					p.SetState(340)
					p.Match(SqlParserNATURAL)
				}
				{
					p.SetState(341)
					p.JoinType()
				}
				{
					p.SetState(342)
					p.Match(SqlParserJOIN)
				}
				{
					p.SetState(343)

					var _x = p.SampledRelation()

					localctx.(*JoinRelationContext).right = _x
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(351)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext())
	}

	return localctx
}

// IJoinTypeContext is an interface to support dynamic dispatch.
type IJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinTypeContext differentiates from other interfaces.
	IsJoinTypeContext()
}

type JoinTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinTypeContext() *JoinTypeContext {
	var p = new(JoinTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_joinType
	return p
}

func (*JoinTypeContext) IsJoinTypeContext() {}

func NewJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinTypeContext {
	var p = new(JoinTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_joinType

	return p
}

func (s *JoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinTypeContext) INNER() antlr.TerminalNode {
	return s.GetToken(SqlParserINNER, 0)
}

func (s *JoinTypeContext) LEFT() antlr.TerminalNode {
	return s.GetToken(SqlParserLEFT, 0)
}

func (s *JoinTypeContext) OUTER() antlr.TerminalNode {
	return s.GetToken(SqlParserOUTER, 0)
}

func (s *JoinTypeContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(SqlParserRIGHT, 0)
}

func (s *JoinTypeContext) FULL() antlr.TerminalNode {
	return s.GetToken(SqlParserFULL, 0)
}

func (s *JoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterJoinType(s)
	}
}

func (s *JoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitJoinType(s)
	}
}

func (s *JoinTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitJoinType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) JoinType() (localctx IJoinTypeContext) {
	localctx = NewJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SqlParserRULE_joinType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(367)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlParserINNER, SqlParserJOIN:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(353)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlParserINNER {
			{
				p.SetState(352)
				p.Match(SqlParserINNER)
			}

		}

	case SqlParserLEFT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(355)
			p.Match(SqlParserLEFT)
		}
		p.SetState(357)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlParserOUTER {
			{
				p.SetState(356)
				p.Match(SqlParserOUTER)
			}

		}

	case SqlParserRIGHT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(359)
			p.Match(SqlParserRIGHT)
		}
		p.SetState(361)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlParserOUTER {
			{
				p.SetState(360)
				p.Match(SqlParserOUTER)
			}

		}

	case SqlParserFULL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(363)
			p.Match(SqlParserFULL)
		}
		p.SetState(365)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlParserOUTER {
			{
				p.SetState(364)
				p.Match(SqlParserOUTER)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IJoinCriteriaContext is an interface to support dynamic dispatch.
type IJoinCriteriaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinCriteriaContext differentiates from other interfaces.
	IsJoinCriteriaContext()
}

type JoinCriteriaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCriteriaContext() *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_joinCriteria
	return p
}

func (*JoinCriteriaContext) IsJoinCriteriaContext() {}

func NewJoinCriteriaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_joinCriteria

	return p
}

func (s *JoinCriteriaContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCriteriaContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlParserON, 0)
}

func (s *JoinCriteriaContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *JoinCriteriaContext) USING() antlr.TerminalNode {
	return s.GetToken(SqlParserUSING, 0)
}

func (s *JoinCriteriaContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *JoinCriteriaContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *JoinCriteriaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCriteriaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCriteriaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitJoinCriteria(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) JoinCriteria() (localctx IJoinCriteriaContext) {
	localctx = NewJoinCriteriaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SqlParserRULE_joinCriteria)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(383)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(369)
			p.Match(SqlParserON)
		}
		{
			p.SetState(370)
			p.booleanExpression(0)
		}

	case SqlParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(371)
			p.Match(SqlParserUSING)
		}
		{
			p.SetState(372)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(373)
			p.Identifier()
		}
		p.SetState(378)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlParserT__0 {
			{
				p.SetState(374)
				p.Match(SqlParserT__0)
			}
			{
				p.SetState(375)
				p.Identifier()
			}

			p.SetState(380)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(381)
			p.Match(SqlParserT__2)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISampledRelationContext is an interface to support dynamic dispatch.
type ISampledRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPercentage returns the percentage rule contexts.
	GetPercentage() IExpressionContext

	// SetPercentage sets the percentage rule contexts.
	SetPercentage(IExpressionContext)

	// IsSampledRelationContext differentiates from other interfaces.
	IsSampledRelationContext()
}

type SampledRelationContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	percentage IExpressionContext
}

func NewEmptySampledRelationContext() *SampledRelationContext {
	var p = new(SampledRelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_sampledRelation
	return p
}

func (*SampledRelationContext) IsSampledRelationContext() {}

func NewSampledRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampledRelationContext {
	var p = new(SampledRelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_sampledRelation

	return p
}

func (s *SampledRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *SampledRelationContext) GetPercentage() IExpressionContext { return s.percentage }

func (s *SampledRelationContext) SetPercentage(v IExpressionContext) { s.percentage = v }

func (s *SampledRelationContext) AliasedRelation() IAliasedRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasedRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasedRelationContext)
}

func (s *SampledRelationContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(SqlParserTABLESAMPLE, 0)
}

func (s *SampledRelationContext) SampleType() ISampleTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISampleTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISampleTypeContext)
}

func (s *SampledRelationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SampledRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampledRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampledRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterSampledRelation(s)
	}
}

func (s *SampledRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitSampledRelation(s)
	}
}

func (s *SampledRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitSampledRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) SampledRelation() (localctx ISampledRelationContext) {
	localctx = NewSampledRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SqlParserRULE_sampledRelation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(385)
		p.AliasedRelation()
	}
	p.SetState(392)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(386)
			p.Match(SqlParserTABLESAMPLE)
		}
		{
			p.SetState(387)
			p.SampleType()
		}
		{
			p.SetState(388)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(389)

			var _x = p.Expression()

			localctx.(*SampledRelationContext).percentage = _x
		}
		{
			p.SetState(390)
			p.Match(SqlParserT__2)
		}

	}

	return localctx
}

// ISampleTypeContext is an interface to support dynamic dispatch.
type ISampleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSampleTypeContext differentiates from other interfaces.
	IsSampleTypeContext()
}

type SampleTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleTypeContext() *SampleTypeContext {
	var p = new(SampleTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_sampleType
	return p
}

func (*SampleTypeContext) IsSampleTypeContext() {}

func NewSampleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleTypeContext {
	var p = new(SampleTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_sampleType

	return p
}

func (s *SampleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleTypeContext) BERNOULLI() antlr.TerminalNode {
	return s.GetToken(SqlParserBERNOULLI, 0)
}

func (s *SampleTypeContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(SqlParserSYSTEM, 0)
}

func (s *SampleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterSampleType(s)
	}
}

func (s *SampleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitSampleType(s)
	}
}

func (s *SampleTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitSampleType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) SampleType() (localctx ISampleTypeContext) {
	localctx = NewSampleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SqlParserRULE_sampleType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(394)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlParserBERNOULLI || _la == SqlParserSYSTEM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAliasedRelationContext is an interface to support dynamic dispatch.
type IAliasedRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAliasedRelationContext differentiates from other interfaces.
	IsAliasedRelationContext()
}

type AliasedRelationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasedRelationContext() *AliasedRelationContext {
	var p = new(AliasedRelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_aliasedRelation
	return p
}

func (*AliasedRelationContext) IsAliasedRelationContext() {}

func NewAliasedRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasedRelationContext {
	var p = new(AliasedRelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_aliasedRelation

	return p
}

func (s *AliasedRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasedRelationContext) RelationPrimary() IRelationPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *AliasedRelationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AliasedRelationContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlParserAS, 0)
}

func (s *AliasedRelationContext) ColumnAliases() IColumnAliasesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnAliasesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *AliasedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasedRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterAliasedRelation(s)
	}
}

func (s *AliasedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitAliasedRelation(s)
	}
}

func (s *AliasedRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitAliasedRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) AliasedRelation() (localctx IAliasedRelationContext) {
	localctx = NewAliasedRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SqlParserRULE_aliasedRelation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(396)
		p.RelationPrimary()
	}
	p.SetState(404)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) == 1 {
		p.SetState(398)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlParserAS {
			{
				p.SetState(397)
				p.Match(SqlParserAS)
			}

		}
		{
			p.SetState(400)
			p.Identifier()
		}
		p.SetState(402)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(401)
				p.ColumnAliases()
			}

		}

	}

	return localctx
}

// IColumnAliasesContext is an interface to support dynamic dispatch.
type IColumnAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnAliasesContext differentiates from other interfaces.
	IsColumnAliasesContext()
}

type ColumnAliasesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAliasesContext() *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_columnAliases
	return p
}

func (*ColumnAliasesContext) IsColumnAliasesContext() {}

func NewColumnAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_columnAliases

	return p
}

func (s *ColumnAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAliasesContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *ColumnAliasesContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitColumnAliases(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) ColumnAliases() (localctx IColumnAliasesContext) {
	localctx = NewColumnAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SqlParserRULE_columnAliases)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(406)
		p.Match(SqlParserT__1)
	}
	{
		p.SetState(407)
		p.Identifier()
	}
	p.SetState(412)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SqlParserT__0 {
		{
			p.SetState(408)
			p.Match(SqlParserT__0)
		}
		{
			p.SetState(409)
			p.Identifier()
		}

		p.SetState(414)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(415)
		p.Match(SqlParserT__2)
	}

	return localctx
}

// IRelationPrimaryContext is an interface to support dynamic dispatch.
type IRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationPrimaryContext differentiates from other interfaces.
	IsRelationPrimaryContext()
}

type RelationPrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationPrimaryContext() *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_relationPrimary
	return p
}

func (*RelationPrimaryContext) IsRelationPrimaryContext() {}

func NewRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_relationPrimary

	return p
}

func (s *RelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationPrimaryContext) CopyFrom(ctx *RelationPrimaryContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *RelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryRelationContext struct {
	*RelationPrimaryContext
}

func NewSubqueryRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryRelationContext {
	var p = new(SubqueryRelationContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *SubqueryRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryRelationContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterSubqueryRelation(s)
	}
}

func (s *SubqueryRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitSubqueryRelation(s)
	}
}

func (s *SubqueryRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitSubqueryRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesizedRelationContext struct {
	*RelationPrimaryContext
}

func NewParenthesizedRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedRelationContext {
	var p = new(ParenthesizedRelationContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *ParenthesizedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedRelationContext) Relation() IRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *ParenthesizedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterParenthesizedRelation(s)
	}
}

func (s *ParenthesizedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitParenthesizedRelation(s)
	}
}

func (s *ParenthesizedRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitParenthesizedRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnnestContext struct {
	*RelationPrimaryContext
}

func NewUnnestContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnnestContext {
	var p = new(UnnestContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *UnnestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnnestContext) UNNEST() antlr.TerminalNode {
	return s.GetToken(SqlParserUNNEST, 0)
}

func (s *UnnestContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *UnnestContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnnestContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlParserWITH, 0)
}

func (s *UnnestContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(SqlParserORDINALITY, 0)
}

func (s *UnnestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterUnnest(s)
	}
}

func (s *UnnestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitUnnest(s)
	}
}

func (s *UnnestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitUnnest(s)

	default:
		return t.VisitChildren(s)
	}
}

type LateralContext struct {
	*RelationPrimaryContext
}

func NewLateralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LateralContext {
	var p = new(LateralContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *LateralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LateralContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(SqlParserLATERAL, 0)
}

func (s *LateralContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *LateralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterLateral(s)
	}
}

func (s *LateralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitLateral(s)
	}
}

func (s *LateralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitLateral(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableNameContext struct {
	*RelationPrimaryContext
}

func NewTableNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableNameContext {
	var p = new(TableNameContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (s *TableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitTableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) RelationPrimary() (localctx IRelationPrimaryContext) {
	localctx = NewRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SqlParserRULE_relationPrimary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(446)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(417)
			p.QualifiedName()
		}

	case 2:
		localctx = NewSubqueryRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(418)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(419)
			p.Query()
		}
		{
			p.SetState(420)
			p.Match(SqlParserT__2)
		}

	case 3:
		localctx = NewUnnestContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(422)
			p.Match(SqlParserUNNEST)
		}
		{
			p.SetState(423)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(424)
			p.Expression()
		}
		p.SetState(429)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlParserT__0 {
			{
				p.SetState(425)
				p.Match(SqlParserT__0)
			}
			{
				p.SetState(426)
				p.Expression()
			}

			p.SetState(431)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(432)
			p.Match(SqlParserT__2)
		}
		p.SetState(435)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(433)
				p.Match(SqlParserWITH)
			}
			{
				p.SetState(434)
				p.Match(SqlParserORDINALITY)
			}

		}

	case 4:
		localctx = NewLateralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(437)
			p.Match(SqlParserLATERAL)
		}
		{
			p.SetState(438)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(439)
			p.Query()
		}
		{
			p.SetState(440)
			p.Match(SqlParserT__2)
		}

	case 5:
		localctx = NewParenthesizedRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(442)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(443)
			p.relation(0)
		}
		{
			p.SetState(444)
			p.Match(SqlParserT__2)
		}

	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SqlParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(448)
		p.booleanExpression(0)
	}

	return localctx
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_booleanExpression
	return p
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyFrom(ctx *BooleanExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LogicalNotContext struct {
	*BooleanExpressionContext
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlParserNOT, 0)
}

func (s *LogicalNotContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterLogicalNot(s)
	}
}

func (s *LogicalNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitLogicalNot(s)
	}
}

func (s *LogicalNotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitLogicalNot(s)

	default:
		return t.VisitChildren(s)
	}
}

type BooleanDefaultContext struct {
	*BooleanExpressionContext
}

func NewBooleanDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanDefaultContext {
	var p = new(BooleanDefaultContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *BooleanDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanDefaultContext) Predicated() IPredicatedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicatedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicatedContext)
}

func (s *BooleanDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterBooleanDefault(s)
	}
}

func (s *BooleanDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitBooleanDefault(s)
	}
}

func (s *BooleanDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitBooleanDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalBinaryContext struct {
	*BooleanExpressionContext
	left     IBooleanExpressionContext
	operator antlr.Token
	right    IBooleanExpressionContext
}

func NewLogicalBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalBinaryContext {
	var p = new(LogicalBinaryContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalBinaryContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *LogicalBinaryContext) GetRight() IBooleanExpressionContext { return s.right }

func (s *LogicalBinaryContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *LogicalBinaryContext) SetRight(v IBooleanExpressionContext) { s.right = v }

func (s *LogicalBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalBinaryContext) AllBooleanExpression() []IBooleanExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem())
	var tst = make([]IBooleanExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBooleanExpressionContext)
		}
	}

	return tst
}

func (s *LogicalBinaryContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalBinaryContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlParserAND, 0)
}

func (s *LogicalBinaryContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlParserOR, 0)
}

func (s *LogicalBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitLogicalBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *SqlParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 58
	p.EnterRecursionRule(localctx, 58, SqlParserRULE_booleanExpression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(454)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlParserT__1, SqlParserT__4, SqlParserADD, SqlParserALL, SqlParserANALYZE, SqlParserANY, SqlParserARRAY, SqlParserASC, SqlParserAT, SqlParserBERNOULLI, SqlParserCALL, SqlParserCASCADE, SqlParserCASE, SqlParserCAST, SqlParserCATALOGS, SqlParserCOALESCE, SqlParserCOLUMN, SqlParserCOLUMNS, SqlParserCOMMENT, SqlParserCOMMIT, SqlParserCOMMITTED, SqlParserCURRENT, SqlParserCURRENT_DATE, SqlParserCURRENT_TIME, SqlParserCURRENT_TIMESTAMP, SqlParserDATA, SqlParserDATE, SqlParserDAY, SqlParserDESC, SqlParserDISTRIBUTED, SqlParserEXCLUDING, SqlParserEXISTS, SqlParserEXPLAIN, SqlParserEXTRACT, SqlParserFALSE, SqlParserFILTER, SqlParserFIRST, SqlParserFOLLOWING, SqlParserFORMAT, SqlParserFUNCTIONS, SqlParserGRANT, SqlParserGRANTS, SqlParserGRAPHVIZ, SqlParserGROUPING, SqlParserHOUR, SqlParserIF, SqlParserINCLUDING, SqlParserINPUT, SqlParserINTEGER, SqlParserINTERVAL, SqlParserISOLATION, SqlParserLAST, SqlParserLATERAL, SqlParserLEVEL, SqlParserLIMIT, SqlParserLOCALTIME, SqlParserLOCALTIMESTAMP, SqlParserLOGICAL, SqlParserMAP, SqlParserMINUTE, SqlParserMONTH, SqlParserNFC, SqlParserNFD, SqlParserNFKC, SqlParserNFKD, SqlParserNO, SqlParserNULL, SqlParserNULLIF, SqlParserNULLS, SqlParserONLY, SqlParserOPTION, SqlParserORDINALITY, SqlParserOUTPUT, SqlParserOVER, SqlParserPARTITION, SqlParserPARTITIONS, SqlParserPOSITION, SqlParserPRECEDING, SqlParserPRIVILEGES, SqlParserPROPERTIES, SqlParserPUBLIC, SqlParserRANGE, SqlParserREAD, SqlParserRENAME, SqlParserREPEATABLE, SqlParserREPLACE, SqlParserRESET, SqlParserRESTRICT, SqlParserREVOKE, SqlParserROLLBACK, SqlParserROW, SqlParserROWS, SqlParserSCHEMA, SqlParserSCHEMAS, SqlParserSECOND, SqlParserSERIALIZABLE, SqlParserSESSION, SqlParserSET, SqlParserSETS, SqlParserSHOW, SqlParserSMALLINT, SqlParserSOME, SqlParserSTART, SqlParserSTATS, SqlParserSUBSTRING, SqlParserSYSTEM, SqlParserTABLES, SqlParserTABLESAMPLE, SqlParserTEXT, SqlParserTIME, SqlParserTIMESTAMP, SqlParserTINYINT, SqlParserTO, SqlParserTRANSACTION, SqlParserTRUE, SqlParserTRY_CAST, SqlParserTYPE, SqlParserUNBOUNDED, SqlParserUNCOMMITTED, SqlParserUSE, SqlParserVALIDATE, SqlParserVERBOSE, SqlParserVIEW, SqlParserWORK, SqlParserWRITE, SqlParserYEAR, SqlParserZONE, SqlParserPLUS, SqlParserMINUS, SqlParserSTRING, SqlParserUNICODE_STRING, SqlParserBINARY_LITERAL, SqlParserINTEGER_VALUE, SqlParserDECIMAL_VALUE, SqlParserDOUBLE_VALUE, SqlParserIDENTIFIER, SqlParserDIGIT_IDENTIFIER, SqlParserQUOTED_IDENTIFIER, SqlParserBACKQUOTED_IDENTIFIER, SqlParserDOUBLE_PRECISION:
		localctx = NewBooleanDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(451)
			p.Predicated()
		}

	case SqlParserNOT:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(452)
			p.Match(SqlParserNOT)
		}
		{
			p.SetState(453)
			p.booleanExpression(3)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(464)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(462)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlParserRULE_booleanExpression)
				p.SetState(456)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(457)

					var _m = p.Match(SqlParserAND)

					localctx.(*LogicalBinaryContext).operator = _m
				}
				{
					p.SetState(458)

					var _x = p.booleanExpression(3)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 2:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlParserRULE_booleanExpression)
				p.SetState(459)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(460)

					var _m = p.Match(SqlParserOR)

					localctx.(*LogicalBinaryContext).operator = _m
				}
				{
					p.SetState(461)

					var _x = p.booleanExpression(2)

					localctx.(*LogicalBinaryContext).right = _x
				}

			}

		}
		p.SetState(466)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext())
	}

	return localctx
}

// IPredicatedContext is an interface to support dynamic dispatch.
type IPredicatedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_valueExpression returns the _valueExpression rule contexts.
	Get_valueExpression() IValueExpressionContext

	// Set_valueExpression sets the _valueExpression rule contexts.
	Set_valueExpression(IValueExpressionContext)

	// IsPredicatedContext differentiates from other interfaces.
	IsPredicatedContext()
}

type PredicatedContext struct {
	*antlr.BaseParserRuleContext
	parser           antlr.Parser
	_valueExpression IValueExpressionContext
}

func NewEmptyPredicatedContext() *PredicatedContext {
	var p = new(PredicatedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_predicated
	return p
}

func (*PredicatedContext) IsPredicatedContext() {}

func NewPredicatedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicatedContext {
	var p = new(PredicatedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_predicated

	return p
}

func (s *PredicatedContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicatedContext) Get_valueExpression() IValueExpressionContext { return s._valueExpression }

func (s *PredicatedContext) Set_valueExpression(v IValueExpressionContext) { s._valueExpression = v }

func (s *PredicatedContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicatedContext) Predicate() IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicatedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterPredicated(s)
	}
}

func (s *PredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitPredicated(s)
	}
}

func (s *PredicatedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitPredicated(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) Predicated() (localctx IPredicatedContext) {
	localctx = NewPredicatedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SqlParserRULE_predicated)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(467)

		var _x = p.valueExpression(0)

		localctx.(*PredicatedContext)._valueExpression = _x
	}
	p.SetState(469)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(468)
			p.Predicate(localctx.(*PredicatedContext).Get_valueExpression())
		}

	}

	return localctx
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value attribute.
	GetValue() antlr.ParserRuleContext

	// SetValue sets the value attribute.
	SetValue(antlr.ParserRuleContext)

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	value  antlr.ParserRuleContext
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_predicate
	return p
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, value antlr.ParserRuleContext) *PredicateContext {
	var p = new(PredicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_predicate

	p.value = value

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) GetValue() antlr.ParserRuleContext { return s.value }

func (s *PredicateContext) SetValue(v antlr.ParserRuleContext) { s.value = v }

func (s *PredicateContext) CopyFrom(ctx *PredicateContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
	s.value = ctx.value
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ComparisonContext struct {
	*PredicateContext
	right IValueExpressionContext
}

func NewComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonContext {
	var p = new(ComparisonContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *ComparisonContext) GetRight() IValueExpressionContext { return s.right }

func (s *ComparisonContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitComparison(s)
	}
}

func (s *ComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

type LikeContext struct {
	*PredicateContext
	pattern IValueExpressionContext
	escape  IValueExpressionContext
}

func NewLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikeContext {
	var p = new(LikeContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *LikeContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *LikeContext) GetEscape() IValueExpressionContext { return s.escape }

func (s *LikeContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *LikeContext) SetEscape(v IValueExpressionContext) { s.escape = v }

func (s *LikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlParserLIKE, 0)
}

func (s *LikeContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *LikeContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *LikeContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlParserNOT, 0)
}

func (s *LikeContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlParserESCAPE, 0)
}

func (s *LikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterLike(s)
	}
}

func (s *LikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitLike(s)
	}
}

func (s *LikeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitLike(s)

	default:
		return t.VisitChildren(s)
	}
}

type InSubqueryContext struct {
	*PredicateContext
}

func NewInSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InSubqueryContext {
	var p = new(InSubqueryContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *InSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InSubqueryContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlParserIN, 0)
}

func (s *InSubqueryContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *InSubqueryContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlParserNOT, 0)
}

func (s *InSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterInSubquery(s)
	}
}

func (s *InSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitInSubquery(s)
	}
}

func (s *InSubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitInSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

type DistinctFromContext struct {
	*PredicateContext
	right IValueExpressionContext
}

func NewDistinctFromContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DistinctFromContext {
	var p = new(DistinctFromContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *DistinctFromContext) GetRight() IValueExpressionContext { return s.right }

func (s *DistinctFromContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *DistinctFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinctFromContext) IS() antlr.TerminalNode {
	return s.GetToken(SqlParserIS, 0)
}

func (s *DistinctFromContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SqlParserDISTINCT, 0)
}

func (s *DistinctFromContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlParserFROM, 0)
}

func (s *DistinctFromContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *DistinctFromContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlParserNOT, 0)
}

func (s *DistinctFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterDistinctFrom(s)
	}
}

func (s *DistinctFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitDistinctFrom(s)
	}
}

func (s *DistinctFromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitDistinctFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

type InListContext struct {
	*PredicateContext
}

func NewInListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InListContext {
	var p = new(InListContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *InListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InListContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlParserIN, 0)
}

func (s *InListContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *InListContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InListContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlParserNOT, 0)
}

func (s *InListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterInList(s)
	}
}

func (s *InListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitInList(s)
	}
}

func (s *InListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitInList(s)

	default:
		return t.VisitChildren(s)
	}
}

type NullPredicateContext struct {
	*PredicateContext
}

func NewNullPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullPredicateContext {
	var p = new(NullPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *NullPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullPredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(SqlParserIS, 0)
}

func (s *NullPredicateContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlParserNULL, 0)
}

func (s *NullPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlParserNOT, 0)
}

func (s *NullPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterNullPredicate(s)
	}
}

func (s *NullPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitNullPredicate(s)
	}
}

func (s *NullPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitNullPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type BetweenContext struct {
	*PredicateContext
	lower IValueExpressionContext
	upper IValueExpressionContext
}

func NewBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenContext {
	var p = new(BetweenContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *BetweenContext) GetLower() IValueExpressionContext { return s.lower }

func (s *BetweenContext) GetUpper() IValueExpressionContext { return s.upper }

func (s *BetweenContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *BetweenContext) SetUpper(v IValueExpressionContext) { s.upper = v }

func (s *BetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SqlParserBETWEEN, 0)
}

func (s *BetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlParserAND, 0)
}

func (s *BetweenContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *BetweenContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *BetweenContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlParserNOT, 0)
}

func (s *BetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterBetween(s)
	}
}

func (s *BetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitBetween(s)
	}
}

func (s *BetweenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitBetween(s)

	default:
		return t.VisitChildren(s)
	}
}

type QuantifiedComparisonContext struct {
	*PredicateContext
}

func NewQuantifiedComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuantifiedComparisonContext {
	var p = new(QuantifiedComparisonContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *QuantifiedComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifiedComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *QuantifiedComparisonContext) ComparisonQuantifier() IComparisonQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonQuantifierContext)
}

func (s *QuantifiedComparisonContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *QuantifiedComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterQuantifiedComparison(s)
	}
}

func (s *QuantifiedComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitQuantifiedComparison(s)
	}
}

func (s *QuantifiedComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitQuantifiedComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) Predicate(value antlr.ParserRuleContext) (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState(), value)
	p.EnterRule(localctx, 62, SqlParserRULE_predicate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(532)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) {
	case 1:
		localctx = NewComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(471)
			p.ComparisonOperator()
		}
		{
			p.SetState(472)

			var _x = p.valueExpression(0)

			localctx.(*ComparisonContext).right = _x
		}

	case 2:
		localctx = NewQuantifiedComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(474)
			p.ComparisonOperator()
		}
		{
			p.SetState(475)
			p.ComparisonQuantifier()
		}
		{
			p.SetState(476)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(477)
			p.Query()
		}
		{
			p.SetState(478)
			p.Match(SqlParserT__2)
		}

	case 3:
		localctx = NewBetweenContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(481)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlParserNOT {
			{
				p.SetState(480)
				p.Match(SqlParserNOT)
			}

		}
		{
			p.SetState(483)
			p.Match(SqlParserBETWEEN)
		}
		{
			p.SetState(484)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).lower = _x
		}
		{
			p.SetState(485)
			p.Match(SqlParserAND)
		}
		{
			p.SetState(486)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).upper = _x
		}

	case 4:
		localctx = NewInListContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(489)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlParserNOT {
			{
				p.SetState(488)
				p.Match(SqlParserNOT)
			}

		}
		{
			p.SetState(491)
			p.Match(SqlParserIN)
		}
		{
			p.SetState(492)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(493)
			p.Expression()
		}
		p.SetState(498)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlParserT__0 {
			{
				p.SetState(494)
				p.Match(SqlParserT__0)
			}
			{
				p.SetState(495)
				p.Expression()
			}

			p.SetState(500)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(501)
			p.Match(SqlParserT__2)
		}

	case 5:
		localctx = NewInSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(504)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlParserNOT {
			{
				p.SetState(503)
				p.Match(SqlParserNOT)
			}

		}
		{
			p.SetState(506)
			p.Match(SqlParserIN)
		}
		{
			p.SetState(507)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(508)
			p.Query()
		}
		{
			p.SetState(509)
			p.Match(SqlParserT__2)
		}

	case 6:
		localctx = NewLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(512)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlParserNOT {
			{
				p.SetState(511)
				p.Match(SqlParserNOT)
			}

		}
		{
			p.SetState(514)
			p.Match(SqlParserLIKE)
		}
		{
			p.SetState(515)

			var _x = p.valueExpression(0)

			localctx.(*LikeContext).pattern = _x
		}
		p.SetState(518)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(516)
				p.Match(SqlParserESCAPE)
			}
			{
				p.SetState(517)

				var _x = p.valueExpression(0)

				localctx.(*LikeContext).escape = _x
			}

		}

	case 7:
		localctx = NewNullPredicateContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(520)
			p.Match(SqlParserIS)
		}
		p.SetState(522)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlParserNOT {
			{
				p.SetState(521)
				p.Match(SqlParserNOT)
			}

		}
		{
			p.SetState(524)
			p.Match(SqlParserNULL)
		}

	case 8:
		localctx = NewDistinctFromContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(525)
			p.Match(SqlParserIS)
		}
		p.SetState(527)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlParserNOT {
			{
				p.SetState(526)
				p.Match(SqlParserNOT)
			}

		}
		{
			p.SetState(529)
			p.Match(SqlParserDISTINCT)
		}
		{
			p.SetState(530)
			p.Match(SqlParserFROM)
		}
		{
			p.SetState(531)

			var _x = p.valueExpression(0)

			localctx.(*DistinctFromContext).right = _x
		}

	}

	return localctx
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_valueExpression
	return p
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyFrom(ctx *ValueExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ValueExpressionDefaultContext struct {
	*ValueExpressionContext
}

func NewValueExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueExpressionDefaultContext {
	var p = new(ValueExpressionDefaultContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionDefaultContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ValueExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitValueExpressionDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConcatenationContext struct {
	*ValueExpressionContext
	left  IValueExpressionContext
	right IValueExpressionContext
}

func NewConcatenationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConcatenationContext {
	var p = new(ConcatenationContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ConcatenationContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ConcatenationContext) GetRight() IValueExpressionContext { return s.right }

func (s *ConcatenationContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ConcatenationContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ConcatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatenationContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(SqlParserCONCAT, 0)
}

func (s *ConcatenationContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *ConcatenationContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ConcatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterConcatenation(s)
	}
}

func (s *ConcatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitConcatenation(s)
	}
}

func (s *ConcatenationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitConcatenation(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArithmeticBinaryContext struct {
	*ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlParserASTERISK, 0)
}

func (s *ArithmeticBinaryContext) SLASH() antlr.TerminalNode {
	return s.GetToken(SqlParserSLASH, 0)
}

func (s *ArithmeticBinaryContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(SqlParserPERCENT, 0)
}

func (s *ArithmeticBinaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SqlParserPLUS, 0)
}

func (s *ArithmeticBinaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlParserMINUS, 0)
}

func (s *ArithmeticBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitArithmeticBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArithmeticUnaryContext struct {
	*ValueExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryContext {
	var p = new(ArithmeticUnaryContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticUnaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticUnaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlParserMINUS, 0)
}

func (s *ArithmeticUnaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SqlParserPLUS, 0)
}

func (s *ArithmeticUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitArithmeticUnary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *SqlParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 64
	p.EnterRecursionRule(localctx, 64, SqlParserRULE_valueExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(538)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlParserT__1, SqlParserT__4, SqlParserADD, SqlParserALL, SqlParserANALYZE, SqlParserANY, SqlParserARRAY, SqlParserASC, SqlParserAT, SqlParserBERNOULLI, SqlParserCALL, SqlParserCASCADE, SqlParserCASE, SqlParserCAST, SqlParserCATALOGS, SqlParserCOALESCE, SqlParserCOLUMN, SqlParserCOLUMNS, SqlParserCOMMENT, SqlParserCOMMIT, SqlParserCOMMITTED, SqlParserCURRENT, SqlParserCURRENT_DATE, SqlParserCURRENT_TIME, SqlParserCURRENT_TIMESTAMP, SqlParserDATA, SqlParserDATE, SqlParserDAY, SqlParserDESC, SqlParserDISTRIBUTED, SqlParserEXCLUDING, SqlParserEXISTS, SqlParserEXPLAIN, SqlParserEXTRACT, SqlParserFALSE, SqlParserFILTER, SqlParserFIRST, SqlParserFOLLOWING, SqlParserFORMAT, SqlParserFUNCTIONS, SqlParserGRANT, SqlParserGRANTS, SqlParserGRAPHVIZ, SqlParserGROUPING, SqlParserHOUR, SqlParserIF, SqlParserINCLUDING, SqlParserINPUT, SqlParserINTEGER, SqlParserINTERVAL, SqlParserISOLATION, SqlParserLAST, SqlParserLATERAL, SqlParserLEVEL, SqlParserLIMIT, SqlParserLOCALTIME, SqlParserLOCALTIMESTAMP, SqlParserLOGICAL, SqlParserMAP, SqlParserMINUTE, SqlParserMONTH, SqlParserNFC, SqlParserNFD, SqlParserNFKC, SqlParserNFKD, SqlParserNO, SqlParserNULL, SqlParserNULLIF, SqlParserNULLS, SqlParserONLY, SqlParserOPTION, SqlParserORDINALITY, SqlParserOUTPUT, SqlParserOVER, SqlParserPARTITION, SqlParserPARTITIONS, SqlParserPOSITION, SqlParserPRECEDING, SqlParserPRIVILEGES, SqlParserPROPERTIES, SqlParserPUBLIC, SqlParserRANGE, SqlParserREAD, SqlParserRENAME, SqlParserREPEATABLE, SqlParserREPLACE, SqlParserRESET, SqlParserRESTRICT, SqlParserREVOKE, SqlParserROLLBACK, SqlParserROW, SqlParserROWS, SqlParserSCHEMA, SqlParserSCHEMAS, SqlParserSECOND, SqlParserSERIALIZABLE, SqlParserSESSION, SqlParserSET, SqlParserSETS, SqlParserSHOW, SqlParserSMALLINT, SqlParserSOME, SqlParserSTART, SqlParserSTATS, SqlParserSUBSTRING, SqlParserSYSTEM, SqlParserTABLES, SqlParserTABLESAMPLE, SqlParserTEXT, SqlParserTIME, SqlParserTIMESTAMP, SqlParserTINYINT, SqlParserTO, SqlParserTRANSACTION, SqlParserTRUE, SqlParserTRY_CAST, SqlParserTYPE, SqlParserUNBOUNDED, SqlParserUNCOMMITTED, SqlParserUSE, SqlParserVALIDATE, SqlParserVERBOSE, SqlParserVIEW, SqlParserWORK, SqlParserWRITE, SqlParserYEAR, SqlParserZONE, SqlParserSTRING, SqlParserUNICODE_STRING, SqlParserBINARY_LITERAL, SqlParserINTEGER_VALUE, SqlParserDECIMAL_VALUE, SqlParserDOUBLE_VALUE, SqlParserIDENTIFIER, SqlParserDIGIT_IDENTIFIER, SqlParserQUOTED_IDENTIFIER, SqlParserBACKQUOTED_IDENTIFIER, SqlParserDOUBLE_PRECISION:
		localctx = NewValueExpressionDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(535)
			p.primaryExpression(0)
		}

	case SqlParserPLUS, SqlParserMINUS:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(536)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArithmeticUnaryContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlParserPLUS || _la == SqlParserMINUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArithmeticUnaryContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(537)
			p.valueExpression(4)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(551)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(549)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlParserRULE_valueExpression)
				p.SetState(540)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(541)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-197)&-(0x1f+1)) == 0 && ((1<<uint((_la-197)))&((1<<(SqlParserASTERISK-197))|(1<<(SqlParserSLASH-197))|(1<<(SqlParserPERCENT-197)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(542)

					var _x = p.valueExpression(4)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlParserRULE_valueExpression)
				p.SetState(543)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(544)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == SqlParserPLUS || _la == SqlParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(545)

					var _x = p.valueExpression(3)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 3:
				localctx = NewConcatenationContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ConcatenationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlParserRULE_valueExpression)
				p.SetState(546)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(547)
					p.Match(SqlParserCONCAT)
				}
				{
					p.SetState(548)

					var _x = p.valueExpression(2)

					localctx.(*ConcatenationContext).right = _x
				}

			}

		}
		p.SetState(553)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext())
	}

	return localctx
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_primaryExpression
	return p
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CopyFrom(ctx *PrimaryExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DereferenceContext struct {
	*PrimaryExpressionContext
	base      IPrimaryExpressionContext
	fieldName IIdentifierContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DereferenceContext) GetBase() IPrimaryExpressionContext { return s.base }

func (s *DereferenceContext) GetFieldName() IIdentifierContext { return s.fieldName }

func (s *DereferenceContext) SetBase(v IPrimaryExpressionContext) { s.base = v }

func (s *DereferenceContext) SetFieldName(v IIdentifierContext) { s.fieldName = v }

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *DereferenceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DereferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterDereference(s)
	}
}

func (s *DereferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitDereference(s)
	}
}

func (s *DereferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitDereference(s)

	default:
		return t.VisitChildren(s)
	}
}

type TypeConstructorContext struct {
	*PrimaryExpressionContext
}

func NewTypeConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeConstructorContext {
	var p = new(TypeConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *TypeConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstructorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeConstructorContext) StringSql() IStringSqlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringSqlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringSqlContext)
}

func (s *TypeConstructorContext) DOUBLE_PRECISION() antlr.TerminalNode {
	return s.GetToken(SqlParserDOUBLE_PRECISION, 0)
}

func (s *TypeConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterTypeConstructor(s)
	}
}

func (s *TypeConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitTypeConstructor(s)
	}
}

func (s *TypeConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitTypeConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

type SpecialDateTimeFunctionContext struct {
	*PrimaryExpressionContext
	name      antlr.Token
	precision antlr.Token
}

func NewSpecialDateTimeFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialDateTimeFunctionContext {
	var p = new(SpecialDateTimeFunctionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SpecialDateTimeFunctionContext) GetName() antlr.Token { return s.name }

func (s *SpecialDateTimeFunctionContext) GetPrecision() antlr.Token { return s.precision }

func (s *SpecialDateTimeFunctionContext) SetName(v antlr.Token) { s.name = v }

func (s *SpecialDateTimeFunctionContext) SetPrecision(v antlr.Token) { s.precision = v }

func (s *SpecialDateTimeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialDateTimeFunctionContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(SqlParserCURRENT_DATE, 0)
}

func (s *SpecialDateTimeFunctionContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(SqlParserCURRENT_TIME, 0)
}

func (s *SpecialDateTimeFunctionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlParserINTEGER_VALUE, 0)
}

func (s *SpecialDateTimeFunctionContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlParserCURRENT_TIMESTAMP, 0)
}

func (s *SpecialDateTimeFunctionContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(SqlParserLOCALTIME, 0)
}

func (s *SpecialDateTimeFunctionContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlParserLOCALTIMESTAMP, 0)
}

func (s *SpecialDateTimeFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterSpecialDateTimeFunction(s)
	}
}

func (s *SpecialDateTimeFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitSpecialDateTimeFunction(s)
	}
}

func (s *SpecialDateTimeFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitSpecialDateTimeFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubstringContext struct {
	*PrimaryExpressionContext
}

func NewSubstringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubstringContext {
	var p = new(SubstringContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubstringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubstringContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(SqlParserSUBSTRING, 0)
}

func (s *SubstringContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *SubstringContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubstringContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlParserFROM, 0)
}

func (s *SubstringContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlParserFOR, 0)
}

func (s *SubstringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterSubstring(s)
	}
}

func (s *SubstringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitSubstring(s)
	}
}

func (s *SubstringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitSubstring(s)

	default:
		return t.VisitChildren(s)
	}
}

type CastContext struct {
	*PrimaryExpressionContext
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) CAST() antlr.TerminalNode {
	return s.GetToken(SqlParserCAST, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlParserAS, 0)
}

func (s *CastContext) TypeSql() ITypeSqlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeSqlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeSqlContext)
}

func (s *CastContext) TRY_CAST() antlr.TerminalNode {
	return s.GetToken(SqlParserTRY_CAST, 0)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitCast(s)
	}
}

func (s *CastContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitCast(s)

	default:
		return t.VisitChildren(s)
	}
}

type LambdaContext struct {
	*PrimaryExpressionContext
}

func NewLambdaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LambdaContext {
	var p = new(LambdaContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LambdaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *LambdaContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterLambda(s)
	}
}

func (s *LambdaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitLambda(s)
	}
}

func (s *LambdaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitLambda(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesizedExpressionContext struct {
	*PrimaryExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitParenthesizedExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParameterContext struct {
	*PrimaryExpressionContext
}

func NewParameterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParameterContext {
	var p = new(ParameterContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (s *ParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

type NumericLiteralContext struct {
	*PrimaryExpressionContext
}

func NewNumericLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitNumericLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type BooleanLiteralContext struct {
	*PrimaryExpressionContext
}

func NewBooleanLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) BooleanValue() IBooleanValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitBooleanLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleCaseContext struct {
	*PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSimpleCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SimpleCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SimpleCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(SqlParserCASE, 0)
}

func (s *SimpleCaseContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SimpleCaseContext) END() antlr.TerminalNode {
	return s.GetToken(SqlParserEND, 0)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem())
	var tst = make([]IWhenClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhenClauseContext)
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SqlParserELSE, 0)
}

func (s *SimpleCaseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

func (s *SimpleCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitSimpleCase(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnReferenceContext struct {
	*PrimaryExpressionContext
}

func NewColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterColumnReference(s)
	}
}

func (s *ColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitColumnReference(s)
	}
}

func (s *ColumnReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitColumnReference(s)

	default:
		return t.VisitChildren(s)
	}
}

type NullLiteralContext struct {
	*PrimaryExpressionContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlParserNULL, 0)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

func (s *NullLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitNullLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type RowConstructorContext struct {
	*PrimaryExpressionContext
}

func NewRowConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RowConstructorContext {
	var p = new(RowConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *RowConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowConstructorContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *RowConstructorContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RowConstructorContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlParserROW, 0)
}

func (s *RowConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterRowConstructor(s)
	}
}

func (s *RowConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitRowConstructor(s)
	}
}

func (s *RowConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitRowConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubscriptContext struct {
	*PrimaryExpressionContext
	value IPrimaryExpressionContext
	index IValueExpressionContext
}

func NewSubscriptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubscriptContext {
	var p = new(SubscriptContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubscriptContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *SubscriptContext) GetIndex() IValueExpressionContext { return s.index }

func (s *SubscriptContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *SubscriptContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *SubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *SubscriptContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterSubscript(s)
	}
}

func (s *SubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitSubscript(s)
	}
}

func (s *SubscriptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitSubscript(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubqueryExpressionContext struct {
	*PrimaryExpressionContext
}

func NewSubqueryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionContext {
	var p = new(SubqueryExpressionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubqueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpressionContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitSubqueryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BinaryLiteralContext struct {
	*PrimaryExpressionContext
}

func NewBinaryLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryLiteralContext {
	var p = new(BinaryLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *BinaryLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryLiteralContext) BINARY_LITERAL() antlr.TerminalNode {
	return s.GetToken(SqlParserBINARY_LITERAL, 0)
}

func (s *BinaryLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterBinaryLiteral(s)
	}
}

func (s *BinaryLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitBinaryLiteral(s)
	}
}

func (s *BinaryLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitBinaryLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExtractContext struct {
	*PrimaryExpressionContext
}

func NewExtractContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractContext {
	var p = new(ExtractContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExtractContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(SqlParserEXTRACT, 0)
}

func (s *ExtractContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExtractContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlParserFROM, 0)
}

func (s *ExtractContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ExtractContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterExtract(s)
	}
}

func (s *ExtractContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitExtract(s)
	}
}

func (s *ExtractContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitExtract(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringLiteralContext struct {
	*PrimaryExpressionContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) StringSql() IStringSqlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringSqlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringSqlContext)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayConstructorContext struct {
	*PrimaryExpressionContext
}

func NewArrayConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayConstructorContext {
	var p = new(ArrayConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArrayConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstructorContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlParserARRAY, 0)
}

func (s *ArrayConstructorContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ArrayConstructorContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitArrayConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

type FunctionCallContext struct {
	*PrimaryExpressionContext
}

func NewFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *FunctionCallContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlParserASTERISK, 0)
}

func (s *FunctionCallContext) Filter() IFilterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFilterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFilterContext)
}

func (s *FunctionCallContext) Over() IOverContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOverContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOverContext)
}

func (s *FunctionCallContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *FunctionCallContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionCallContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SqlParserORDER, 0)
}

func (s *FunctionCallContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlParserBY, 0)
}

func (s *FunctionCallContext) AllSortItem() []ISortItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortItemContext)(nil)).Elem())
	var tst = make([]ISortItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortItemContext)
		}
	}

	return tst
}

func (s *FunctionCallContext) SortItem(i int) ISortItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *FunctionCallContext) SetQuantifier() ISetQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (s *FunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExistsContext struct {
	*PrimaryExpressionContext
}

func NewExistsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsContext {
	var p = new(ExistsContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlParserEXISTS, 0)
}

func (s *ExistsContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *ExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterExists(s)
	}
}

func (s *ExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitExists(s)
	}
}

func (s *ExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitExists(s)

	default:
		return t.VisitChildren(s)
	}
}

type PositionContext struct {
	*PrimaryExpressionContext
}

func NewPositionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PositionContext {
	var p = new(PositionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *PositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PositionContext) POSITION() antlr.TerminalNode {
	return s.GetToken(SqlParserPOSITION, 0)
}

func (s *PositionContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *PositionContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PositionContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlParserIN, 0)
}

func (s *PositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterPosition(s)
	}
}

func (s *PositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitPosition(s)
	}
}

func (s *PositionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitPosition(s)

	default:
		return t.VisitChildren(s)
	}
}

type SearchedCaseContext struct {
	*PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSearchedCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SearchedCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SearchedCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(SqlParserCASE, 0)
}

func (s *SearchedCaseContext) END() antlr.TerminalNode {
	return s.GetToken(SqlParserEND, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem())
	var tst = make([]IWhenClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhenClauseContext)
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SqlParserELSE, 0)
}

func (s *SearchedCaseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

func (s *SearchedCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitSearchedCase(s)

	default:
		return t.VisitChildren(s)
	}
}

type GroupingOperationContext struct {
	*PrimaryExpressionContext
}

func NewGroupingOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GroupingOperationContext {
	var p = new(GroupingOperationContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *GroupingOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingOperationContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(SqlParserGROUPING, 0)
}

func (s *GroupingOperationContext) AllQualifiedName() []IQualifiedNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem())
	var tst = make([]IQualifiedNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedNameContext)
		}
	}

	return tst
}

func (s *GroupingOperationContext) QualifiedName(i int) IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *GroupingOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterGroupingOperation(s)
	}
}

func (s *GroupingOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitGroupingOperation(s)
	}
}

func (s *GroupingOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitGroupingOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	return p.primaryExpression(0)
}

func (p *SqlParser) primaryExpression(_p int) (localctx IPrimaryExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 66
	p.EnterRecursionRule(localctx, 66, SqlParserRULE_primaryExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(779)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNullLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(555)
			p.Match(SqlParserNULL)
		}

	case 2:
		localctx = NewTypeConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(556)
			p.Identifier()
		}
		{
			p.SetState(557)
			p.StringSql()
		}

	case 3:
		localctx = NewTypeConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(559)
			p.Match(SqlParserDOUBLE_PRECISION)
		}
		{
			p.SetState(560)
			p.StringSql()
		}

	case 4:
		localctx = NewNumericLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(561)
			p.Number()
		}

	case 5:
		localctx = NewBooleanLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(562)
			p.BooleanValue()
		}

	case 6:
		localctx = NewStringLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(563)
			p.StringSql()
		}

	case 7:
		localctx = NewBinaryLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(564)
			p.Match(SqlParserBINARY_LITERAL)
		}

	case 8:
		localctx = NewParameterContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(565)
			p.Match(SqlParserT__4)
		}

	case 9:
		localctx = NewPositionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(566)
			p.Match(SqlParserPOSITION)
		}
		{
			p.SetState(567)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(568)
			p.valueExpression(0)
		}
		{
			p.SetState(569)
			p.Match(SqlParserIN)
		}
		{
			p.SetState(570)
			p.valueExpression(0)
		}
		{
			p.SetState(571)
			p.Match(SqlParserT__2)
		}

	case 10:
		localctx = NewRowConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(573)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(574)
			p.Expression()
		}
		p.SetState(577)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlParserT__0 {
			{
				p.SetState(575)
				p.Match(SqlParserT__0)
			}
			{
				p.SetState(576)
				p.Expression()
			}

			p.SetState(579)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(581)
			p.Match(SqlParserT__2)
		}

	case 11:
		localctx = NewRowConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(583)
			p.Match(SqlParserROW)
		}
		{
			p.SetState(584)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(585)
			p.Expression()
		}
		p.SetState(590)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlParserT__0 {
			{
				p.SetState(586)
				p.Match(SqlParserT__0)
			}
			{
				p.SetState(587)
				p.Expression()
			}

			p.SetState(592)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(593)
			p.Match(SqlParserT__2)
		}

	case 12:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(595)
			p.QualifiedName()
		}
		{
			p.SetState(596)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(597)
			p.Match(SqlParserASTERISK)
		}
		{
			p.SetState(598)
			p.Match(SqlParserT__2)
		}
		p.SetState(600)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(599)
				p.Filter()
			}

		}
		p.SetState(603)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(602)
				p.Over()
			}

		}

	case 13:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(605)
			p.QualifiedName()
		}
		{
			p.SetState(606)
			p.Match(SqlParserT__1)
		}
		p.SetState(618)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlParserT__1)|(1<<SqlParserT__4)|(1<<SqlParserADD)|(1<<SqlParserALL)|(1<<SqlParserANALYZE)|(1<<SqlParserANY)|(1<<SqlParserARRAY)|(1<<SqlParserASC)|(1<<SqlParserAT)|(1<<SqlParserBERNOULLI)|(1<<SqlParserCALL)|(1<<SqlParserCASCADE)|(1<<SqlParserCASE)|(1<<SqlParserCAST)|(1<<SqlParserCATALOGS)|(1<<SqlParserCOALESCE)|(1<<SqlParserCOLUMN)|(1<<SqlParserCOLUMNS)|(1<<SqlParserCOMMENT)|(1<<SqlParserCOMMIT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlParserCOMMITTED-32))|(1<<(SqlParserCURRENT-32))|(1<<(SqlParserCURRENT_DATE-32))|(1<<(SqlParserCURRENT_TIME-32))|(1<<(SqlParserCURRENT_TIMESTAMP-32))|(1<<(SqlParserDATA-32))|(1<<(SqlParserDATE-32))|(1<<(SqlParserDAY-32))|(1<<(SqlParserDESC-32))|(1<<(SqlParserDISTINCT-32))|(1<<(SqlParserDISTRIBUTED-32))|(1<<(SqlParserEXCLUDING-32))|(1<<(SqlParserEXISTS-32))|(1<<(SqlParserEXPLAIN-32))|(1<<(SqlParserEXTRACT-32))|(1<<(SqlParserFALSE-32))|(1<<(SqlParserFILTER-32))|(1<<(SqlParserFIRST-32))|(1<<(SqlParserFOLLOWING-32)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(SqlParserFORMAT-65))|(1<<(SqlParserFUNCTIONS-65))|(1<<(SqlParserGRANT-65))|(1<<(SqlParserGRANTS-65))|(1<<(SqlParserGRAPHVIZ-65))|(1<<(SqlParserGROUPING-65))|(1<<(SqlParserHOUR-65))|(1<<(SqlParserIF-65))|(1<<(SqlParserINCLUDING-65))|(1<<(SqlParserINPUT-65))|(1<<(SqlParserINTEGER-65))|(1<<(SqlParserINTERVAL-65))|(1<<(SqlParserISOLATION-65))|(1<<(SqlParserLAST-65))|(1<<(SqlParserLATERAL-65))|(1<<(SqlParserLEVEL-65))|(1<<(SqlParserLIMIT-65))|(1<<(SqlParserLOCALTIME-65))|(1<<(SqlParserLOCALTIMESTAMP-65)))) != 0) || (((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(SqlParserLOGICAL-97))|(1<<(SqlParserMAP-97))|(1<<(SqlParserMINUTE-97))|(1<<(SqlParserMONTH-97))|(1<<(SqlParserNFC-97))|(1<<(SqlParserNFD-97))|(1<<(SqlParserNFKC-97))|(1<<(SqlParserNFKD-97))|(1<<(SqlParserNO-97))|(1<<(SqlParserNOT-97))|(1<<(SqlParserNULL-97))|(1<<(SqlParserNULLIF-97))|(1<<(SqlParserNULLS-97))|(1<<(SqlParserONLY-97))|(1<<(SqlParserOPTION-97))|(1<<(SqlParserORDINALITY-97))|(1<<(SqlParserOUTPUT-97))|(1<<(SqlParserOVER-97))|(1<<(SqlParserPARTITION-97))|(1<<(SqlParserPARTITIONS-97))|(1<<(SqlParserPOSITION-97))|(1<<(SqlParserPRECEDING-97))|(1<<(SqlParserPRIVILEGES-97))|(1<<(SqlParserPROPERTIES-97))|(1<<(SqlParserPUBLIC-97)))) != 0) || (((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(SqlParserRANGE-129))|(1<<(SqlParserREAD-129))|(1<<(SqlParserRENAME-129))|(1<<(SqlParserREPEATABLE-129))|(1<<(SqlParserREPLACE-129))|(1<<(SqlParserRESET-129))|(1<<(SqlParserRESTRICT-129))|(1<<(SqlParserREVOKE-129))|(1<<(SqlParserROLLBACK-129))|(1<<(SqlParserROW-129))|(1<<(SqlParserROWS-129))|(1<<(SqlParserSCHEMA-129))|(1<<(SqlParserSCHEMAS-129))|(1<<(SqlParserSECOND-129))|(1<<(SqlParserSERIALIZABLE-129))|(1<<(SqlParserSESSION-129))|(1<<(SqlParserSET-129))|(1<<(SqlParserSETS-129))|(1<<(SqlParserSHOW-129))|(1<<(SqlParserSMALLINT-129))|(1<<(SqlParserSOME-129))|(1<<(SqlParserSTART-129))|(1<<(SqlParserSTATS-129))|(1<<(SqlParserSUBSTRING-129))|(1<<(SqlParserSYSTEM-129))|(1<<(SqlParserTABLES-129))|(1<<(SqlParserTABLESAMPLE-129)))) != 0) || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SqlParserTEXT-161))|(1<<(SqlParserTIME-161))|(1<<(SqlParserTIMESTAMP-161))|(1<<(SqlParserTINYINT-161))|(1<<(SqlParserTO-161))|(1<<(SqlParserTRANSACTION-161))|(1<<(SqlParserTRUE-161))|(1<<(SqlParserTRY_CAST-161))|(1<<(SqlParserTYPE-161))|(1<<(SqlParserUNBOUNDED-161))|(1<<(SqlParserUNCOMMITTED-161))|(1<<(SqlParserUSE-161))|(1<<(SqlParserVALIDATE-161))|(1<<(SqlParserVERBOSE-161))|(1<<(SqlParserVIEW-161))|(1<<(SqlParserWORK-161))|(1<<(SqlParserWRITE-161))|(1<<(SqlParserYEAR-161))|(1<<(SqlParserZONE-161)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SqlParserPLUS-195))|(1<<(SqlParserMINUS-195))|(1<<(SqlParserSTRING-195))|(1<<(SqlParserUNICODE_STRING-195))|(1<<(SqlParserBINARY_LITERAL-195))|(1<<(SqlParserINTEGER_VALUE-195))|(1<<(SqlParserDECIMAL_VALUE-195))|(1<<(SqlParserDOUBLE_VALUE-195))|(1<<(SqlParserIDENTIFIER-195))|(1<<(SqlParserDIGIT_IDENTIFIER-195))|(1<<(SqlParserQUOTED_IDENTIFIER-195))|(1<<(SqlParserBACKQUOTED_IDENTIFIER-195))|(1<<(SqlParserDOUBLE_PRECISION-195)))) != 0) {
			p.SetState(608)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(607)
					p.SetQuantifier()
				}

			}
			{
				p.SetState(610)
				p.Expression()
			}
			p.SetState(615)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlParserT__0 {
				{
					p.SetState(611)
					p.Match(SqlParserT__0)
				}
				{
					p.SetState(612)
					p.Expression()
				}

				p.SetState(617)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(630)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlParserORDER {
			{
				p.SetState(620)
				p.Match(SqlParserORDER)
			}
			{
				p.SetState(621)
				p.Match(SqlParserBY)
			}
			{
				p.SetState(622)
				p.SortItem()
			}
			p.SetState(627)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlParserT__0 {
				{
					p.SetState(623)
					p.Match(SqlParserT__0)
				}
				{
					p.SetState(624)
					p.SortItem()
				}

				p.SetState(629)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(632)
			p.Match(SqlParserT__2)
		}
		p.SetState(634)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(633)
				p.Filter()
			}

		}
		p.SetState(637)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(636)
				p.Over()
			}

		}

	case 14:
		localctx = NewLambdaContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(639)
			p.Identifier()
		}
		{
			p.SetState(640)
			p.Match(SqlParserT__5)
		}
		{
			p.SetState(641)
			p.Expression()
		}

	case 15:
		localctx = NewLambdaContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(643)
			p.Match(SqlParserT__1)
		}
		p.SetState(652)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlParserADD)|(1<<SqlParserALL)|(1<<SqlParserANALYZE)|(1<<SqlParserANY)|(1<<SqlParserARRAY)|(1<<SqlParserASC)|(1<<SqlParserAT)|(1<<SqlParserBERNOULLI)|(1<<SqlParserCALL)|(1<<SqlParserCASCADE)|(1<<SqlParserCATALOGS)|(1<<SqlParserCOALESCE)|(1<<SqlParserCOLUMN)|(1<<SqlParserCOLUMNS)|(1<<SqlParserCOMMENT)|(1<<SqlParserCOMMIT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlParserCOMMITTED-32))|(1<<(SqlParserCURRENT-32))|(1<<(SqlParserDATA-32))|(1<<(SqlParserDATE-32))|(1<<(SqlParserDAY-32))|(1<<(SqlParserDESC-32))|(1<<(SqlParserDISTRIBUTED-32))|(1<<(SqlParserEXCLUDING-32))|(1<<(SqlParserEXPLAIN-32))|(1<<(SqlParserFILTER-32))|(1<<(SqlParserFIRST-32))|(1<<(SqlParserFOLLOWING-32)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(SqlParserFORMAT-65))|(1<<(SqlParserFUNCTIONS-65))|(1<<(SqlParserGRANT-65))|(1<<(SqlParserGRANTS-65))|(1<<(SqlParserGRAPHVIZ-65))|(1<<(SqlParserHOUR-65))|(1<<(SqlParserIF-65))|(1<<(SqlParserINCLUDING-65))|(1<<(SqlParserINPUT-65))|(1<<(SqlParserINTEGER-65))|(1<<(SqlParserINTERVAL-65))|(1<<(SqlParserISOLATION-65))|(1<<(SqlParserLAST-65))|(1<<(SqlParserLATERAL-65))|(1<<(SqlParserLEVEL-65))|(1<<(SqlParserLIMIT-65)))) != 0) || (((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(SqlParserLOGICAL-97))|(1<<(SqlParserMAP-97))|(1<<(SqlParserMINUTE-97))|(1<<(SqlParserMONTH-97))|(1<<(SqlParserNFC-97))|(1<<(SqlParserNFD-97))|(1<<(SqlParserNFKC-97))|(1<<(SqlParserNFKD-97))|(1<<(SqlParserNO-97))|(1<<(SqlParserNULLIF-97))|(1<<(SqlParserNULLS-97))|(1<<(SqlParserONLY-97))|(1<<(SqlParserOPTION-97))|(1<<(SqlParserORDINALITY-97))|(1<<(SqlParserOUTPUT-97))|(1<<(SqlParserOVER-97))|(1<<(SqlParserPARTITION-97))|(1<<(SqlParserPARTITIONS-97))|(1<<(SqlParserPOSITION-97))|(1<<(SqlParserPRECEDING-97))|(1<<(SqlParserPRIVILEGES-97))|(1<<(SqlParserPROPERTIES-97))|(1<<(SqlParserPUBLIC-97)))) != 0) || (((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(SqlParserRANGE-129))|(1<<(SqlParserREAD-129))|(1<<(SqlParserRENAME-129))|(1<<(SqlParserREPEATABLE-129))|(1<<(SqlParserREPLACE-129))|(1<<(SqlParserRESET-129))|(1<<(SqlParserRESTRICT-129))|(1<<(SqlParserREVOKE-129))|(1<<(SqlParserROLLBACK-129))|(1<<(SqlParserROW-129))|(1<<(SqlParserROWS-129))|(1<<(SqlParserSCHEMA-129))|(1<<(SqlParserSCHEMAS-129))|(1<<(SqlParserSECOND-129))|(1<<(SqlParserSERIALIZABLE-129))|(1<<(SqlParserSESSION-129))|(1<<(SqlParserSET-129))|(1<<(SqlParserSETS-129))|(1<<(SqlParserSHOW-129))|(1<<(SqlParserSMALLINT-129))|(1<<(SqlParserSOME-129))|(1<<(SqlParserSTART-129))|(1<<(SqlParserSTATS-129))|(1<<(SqlParserSUBSTRING-129))|(1<<(SqlParserSYSTEM-129))|(1<<(SqlParserTABLES-129))|(1<<(SqlParserTABLESAMPLE-129)))) != 0) || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SqlParserTEXT-161))|(1<<(SqlParserTIME-161))|(1<<(SqlParserTIMESTAMP-161))|(1<<(SqlParserTINYINT-161))|(1<<(SqlParserTO-161))|(1<<(SqlParserTRANSACTION-161))|(1<<(SqlParserTRY_CAST-161))|(1<<(SqlParserTYPE-161))|(1<<(SqlParserUNBOUNDED-161))|(1<<(SqlParserUNCOMMITTED-161))|(1<<(SqlParserUSE-161))|(1<<(SqlParserVALIDATE-161))|(1<<(SqlParserVERBOSE-161))|(1<<(SqlParserVIEW-161))|(1<<(SqlParserWORK-161))|(1<<(SqlParserWRITE-161))|(1<<(SqlParserYEAR-161))|(1<<(SqlParserZONE-161)))) != 0) || (((_la-207)&-(0x1f+1)) == 0 && ((1<<uint((_la-207)))&((1<<(SqlParserIDENTIFIER-207))|(1<<(SqlParserDIGIT_IDENTIFIER-207))|(1<<(SqlParserQUOTED_IDENTIFIER-207))|(1<<(SqlParserBACKQUOTED_IDENTIFIER-207)))) != 0) {
			{
				p.SetState(644)
				p.Identifier()
			}
			p.SetState(649)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlParserT__0 {
				{
					p.SetState(645)
					p.Match(SqlParserT__0)
				}
				{
					p.SetState(646)
					p.Identifier()
				}

				p.SetState(651)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(654)
			p.Match(SqlParserT__2)
		}
		{
			p.SetState(655)
			p.Match(SqlParserT__5)
		}
		{
			p.SetState(656)
			p.Expression()
		}

	case 16:
		localctx = NewSubqueryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(657)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(658)
			p.Query()
		}
		{
			p.SetState(659)
			p.Match(SqlParserT__2)
		}

	case 17:
		localctx = NewExistsContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(661)
			p.Match(SqlParserEXISTS)
		}
		{
			p.SetState(662)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(663)
			p.Query()
		}
		{
			p.SetState(664)
			p.Match(SqlParserT__2)
		}

	case 18:
		localctx = NewSimpleCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(666)
			p.Match(SqlParserCASE)
		}
		{
			p.SetState(667)
			p.valueExpression(0)
		}
		p.SetState(669)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlParserWHEN {
			{
				p.SetState(668)
				p.WhenClause()
			}

			p.SetState(671)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(675)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlParserELSE {
			{
				p.SetState(673)
				p.Match(SqlParserELSE)
			}
			{
				p.SetState(674)

				var _x = p.Expression()

				localctx.(*SimpleCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(677)
			p.Match(SqlParserEND)
		}

	case 19:
		localctx = NewSearchedCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(679)
			p.Match(SqlParserCASE)
		}
		p.SetState(681)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlParserWHEN {
			{
				p.SetState(680)
				p.WhenClause()
			}

			p.SetState(683)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(687)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlParserELSE {
			{
				p.SetState(685)
				p.Match(SqlParserELSE)
			}
			{
				p.SetState(686)

				var _x = p.Expression()

				localctx.(*SearchedCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(689)
			p.Match(SqlParserEND)
		}

	case 20:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(691)
			p.Match(SqlParserCAST)
		}
		{
			p.SetState(692)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(693)
			p.Expression()
		}
		{
			p.SetState(694)
			p.Match(SqlParserAS)
		}
		{
			p.SetState(695)
			p.typeSql(0)
		}
		{
			p.SetState(696)
			p.Match(SqlParserT__2)
		}

	case 21:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(698)
			p.Match(SqlParserTRY_CAST)
		}
		{
			p.SetState(699)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(700)
			p.Expression()
		}
		{
			p.SetState(701)
			p.Match(SqlParserAS)
		}
		{
			p.SetState(702)
			p.typeSql(0)
		}
		{
			p.SetState(703)
			p.Match(SqlParserT__2)
		}

	case 22:
		localctx = NewArrayConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(705)
			p.Match(SqlParserARRAY)
		}
		{
			p.SetState(706)
			p.Match(SqlParserT__6)
		}
		p.SetState(715)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlParserT__1)|(1<<SqlParserT__4)|(1<<SqlParserADD)|(1<<SqlParserALL)|(1<<SqlParserANALYZE)|(1<<SqlParserANY)|(1<<SqlParserARRAY)|(1<<SqlParserASC)|(1<<SqlParserAT)|(1<<SqlParserBERNOULLI)|(1<<SqlParserCALL)|(1<<SqlParserCASCADE)|(1<<SqlParserCASE)|(1<<SqlParserCAST)|(1<<SqlParserCATALOGS)|(1<<SqlParserCOALESCE)|(1<<SqlParserCOLUMN)|(1<<SqlParserCOLUMNS)|(1<<SqlParserCOMMENT)|(1<<SqlParserCOMMIT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlParserCOMMITTED-32))|(1<<(SqlParserCURRENT-32))|(1<<(SqlParserCURRENT_DATE-32))|(1<<(SqlParserCURRENT_TIME-32))|(1<<(SqlParserCURRENT_TIMESTAMP-32))|(1<<(SqlParserDATA-32))|(1<<(SqlParserDATE-32))|(1<<(SqlParserDAY-32))|(1<<(SqlParserDESC-32))|(1<<(SqlParserDISTRIBUTED-32))|(1<<(SqlParserEXCLUDING-32))|(1<<(SqlParserEXISTS-32))|(1<<(SqlParserEXPLAIN-32))|(1<<(SqlParserEXTRACT-32))|(1<<(SqlParserFALSE-32))|(1<<(SqlParserFILTER-32))|(1<<(SqlParserFIRST-32))|(1<<(SqlParserFOLLOWING-32)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(SqlParserFORMAT-65))|(1<<(SqlParserFUNCTIONS-65))|(1<<(SqlParserGRANT-65))|(1<<(SqlParserGRANTS-65))|(1<<(SqlParserGRAPHVIZ-65))|(1<<(SqlParserGROUPING-65))|(1<<(SqlParserHOUR-65))|(1<<(SqlParserIF-65))|(1<<(SqlParserINCLUDING-65))|(1<<(SqlParserINPUT-65))|(1<<(SqlParserINTEGER-65))|(1<<(SqlParserINTERVAL-65))|(1<<(SqlParserISOLATION-65))|(1<<(SqlParserLAST-65))|(1<<(SqlParserLATERAL-65))|(1<<(SqlParserLEVEL-65))|(1<<(SqlParserLIMIT-65))|(1<<(SqlParserLOCALTIME-65))|(1<<(SqlParserLOCALTIMESTAMP-65)))) != 0) || (((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(SqlParserLOGICAL-97))|(1<<(SqlParserMAP-97))|(1<<(SqlParserMINUTE-97))|(1<<(SqlParserMONTH-97))|(1<<(SqlParserNFC-97))|(1<<(SqlParserNFD-97))|(1<<(SqlParserNFKC-97))|(1<<(SqlParserNFKD-97))|(1<<(SqlParserNO-97))|(1<<(SqlParserNOT-97))|(1<<(SqlParserNULL-97))|(1<<(SqlParserNULLIF-97))|(1<<(SqlParserNULLS-97))|(1<<(SqlParserONLY-97))|(1<<(SqlParserOPTION-97))|(1<<(SqlParserORDINALITY-97))|(1<<(SqlParserOUTPUT-97))|(1<<(SqlParserOVER-97))|(1<<(SqlParserPARTITION-97))|(1<<(SqlParserPARTITIONS-97))|(1<<(SqlParserPOSITION-97))|(1<<(SqlParserPRECEDING-97))|(1<<(SqlParserPRIVILEGES-97))|(1<<(SqlParserPROPERTIES-97))|(1<<(SqlParserPUBLIC-97)))) != 0) || (((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(SqlParserRANGE-129))|(1<<(SqlParserREAD-129))|(1<<(SqlParserRENAME-129))|(1<<(SqlParserREPEATABLE-129))|(1<<(SqlParserREPLACE-129))|(1<<(SqlParserRESET-129))|(1<<(SqlParserRESTRICT-129))|(1<<(SqlParserREVOKE-129))|(1<<(SqlParserROLLBACK-129))|(1<<(SqlParserROW-129))|(1<<(SqlParserROWS-129))|(1<<(SqlParserSCHEMA-129))|(1<<(SqlParserSCHEMAS-129))|(1<<(SqlParserSECOND-129))|(1<<(SqlParserSERIALIZABLE-129))|(1<<(SqlParserSESSION-129))|(1<<(SqlParserSET-129))|(1<<(SqlParserSETS-129))|(1<<(SqlParserSHOW-129))|(1<<(SqlParserSMALLINT-129))|(1<<(SqlParserSOME-129))|(1<<(SqlParserSTART-129))|(1<<(SqlParserSTATS-129))|(1<<(SqlParserSUBSTRING-129))|(1<<(SqlParserSYSTEM-129))|(1<<(SqlParserTABLES-129))|(1<<(SqlParserTABLESAMPLE-129)))) != 0) || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SqlParserTEXT-161))|(1<<(SqlParserTIME-161))|(1<<(SqlParserTIMESTAMP-161))|(1<<(SqlParserTINYINT-161))|(1<<(SqlParserTO-161))|(1<<(SqlParserTRANSACTION-161))|(1<<(SqlParserTRUE-161))|(1<<(SqlParserTRY_CAST-161))|(1<<(SqlParserTYPE-161))|(1<<(SqlParserUNBOUNDED-161))|(1<<(SqlParserUNCOMMITTED-161))|(1<<(SqlParserUSE-161))|(1<<(SqlParserVALIDATE-161))|(1<<(SqlParserVERBOSE-161))|(1<<(SqlParserVIEW-161))|(1<<(SqlParserWORK-161))|(1<<(SqlParserWRITE-161))|(1<<(SqlParserYEAR-161))|(1<<(SqlParserZONE-161)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SqlParserPLUS-195))|(1<<(SqlParserMINUS-195))|(1<<(SqlParserSTRING-195))|(1<<(SqlParserUNICODE_STRING-195))|(1<<(SqlParserBINARY_LITERAL-195))|(1<<(SqlParserINTEGER_VALUE-195))|(1<<(SqlParserDECIMAL_VALUE-195))|(1<<(SqlParserDOUBLE_VALUE-195))|(1<<(SqlParserIDENTIFIER-195))|(1<<(SqlParserDIGIT_IDENTIFIER-195))|(1<<(SqlParserQUOTED_IDENTIFIER-195))|(1<<(SqlParserBACKQUOTED_IDENTIFIER-195))|(1<<(SqlParserDOUBLE_PRECISION-195)))) != 0) {
			{
				p.SetState(707)
				p.Expression()
			}
			p.SetState(712)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlParserT__0 {
				{
					p.SetState(708)
					p.Match(SqlParserT__0)
				}
				{
					p.SetState(709)
					p.Expression()
				}

				p.SetState(714)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(717)
			p.Match(SqlParserT__7)
		}

	case 23:
		localctx = NewColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(718)
			p.Identifier()
		}

	case 24:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(719)

			var _m = p.Match(SqlParserCURRENT_DATE)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}

	case 25:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(720)

			var _m = p.Match(SqlParserCURRENT_TIME)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}
		p.SetState(724)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(721)
				p.Match(SqlParserT__1)
			}
			{
				p.SetState(722)

				var _m = p.Match(SqlParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
			}
			{
				p.SetState(723)
				p.Match(SqlParserT__2)
			}

		}

	case 26:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(726)

			var _m = p.Match(SqlParserCURRENT_TIMESTAMP)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}
		p.SetState(730)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(727)
				p.Match(SqlParserT__1)
			}
			{
				p.SetState(728)

				var _m = p.Match(SqlParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
			}
			{
				p.SetState(729)
				p.Match(SqlParserT__2)
			}

		}

	case 27:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(732)

			var _m = p.Match(SqlParserLOCALTIME)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}
		p.SetState(736)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(733)
				p.Match(SqlParserT__1)
			}
			{
				p.SetState(734)

				var _m = p.Match(SqlParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
			}
			{
				p.SetState(735)
				p.Match(SqlParserT__2)
			}

		}

	case 28:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(738)

			var _m = p.Match(SqlParserLOCALTIMESTAMP)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}
		p.SetState(742)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(739)
				p.Match(SqlParserT__1)
			}
			{
				p.SetState(740)

				var _m = p.Match(SqlParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
			}
			{
				p.SetState(741)
				p.Match(SqlParserT__2)
			}

		}

	case 29:
		localctx = NewSubstringContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(744)
			p.Match(SqlParserSUBSTRING)
		}
		{
			p.SetState(745)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(746)
			p.valueExpression(0)
		}
		{
			p.SetState(747)
			p.Match(SqlParserFROM)
		}
		{
			p.SetState(748)
			p.valueExpression(0)
		}
		p.SetState(751)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlParserFOR {
			{
				p.SetState(749)
				p.Match(SqlParserFOR)
			}
			{
				p.SetState(750)
				p.valueExpression(0)
			}

		}
		{
			p.SetState(753)
			p.Match(SqlParserT__2)
		}

	case 30:
		localctx = NewExtractContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(755)
			p.Match(SqlParserEXTRACT)
		}
		{
			p.SetState(756)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(757)
			p.Identifier()
		}
		{
			p.SetState(758)
			p.Match(SqlParserFROM)
		}
		{
			p.SetState(759)
			p.valueExpression(0)
		}
		{
			p.SetState(760)
			p.Match(SqlParserT__2)
		}

	case 31:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(762)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(763)
			p.Expression()
		}
		{
			p.SetState(764)
			p.Match(SqlParserT__2)
		}

	case 32:
		localctx = NewGroupingOperationContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(766)
			p.Match(SqlParserGROUPING)
		}
		{
			p.SetState(767)
			p.Match(SqlParserT__1)
		}
		p.SetState(776)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlParserADD)|(1<<SqlParserALL)|(1<<SqlParserANALYZE)|(1<<SqlParserANY)|(1<<SqlParserARRAY)|(1<<SqlParserASC)|(1<<SqlParserAT)|(1<<SqlParserBERNOULLI)|(1<<SqlParserCALL)|(1<<SqlParserCASCADE)|(1<<SqlParserCATALOGS)|(1<<SqlParserCOALESCE)|(1<<SqlParserCOLUMN)|(1<<SqlParserCOLUMNS)|(1<<SqlParserCOMMENT)|(1<<SqlParserCOMMIT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlParserCOMMITTED-32))|(1<<(SqlParserCURRENT-32))|(1<<(SqlParserDATA-32))|(1<<(SqlParserDATE-32))|(1<<(SqlParserDAY-32))|(1<<(SqlParserDESC-32))|(1<<(SqlParserDISTRIBUTED-32))|(1<<(SqlParserEXCLUDING-32))|(1<<(SqlParserEXPLAIN-32))|(1<<(SqlParserFILTER-32))|(1<<(SqlParserFIRST-32))|(1<<(SqlParserFOLLOWING-32)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(SqlParserFORMAT-65))|(1<<(SqlParserFUNCTIONS-65))|(1<<(SqlParserGRANT-65))|(1<<(SqlParserGRANTS-65))|(1<<(SqlParserGRAPHVIZ-65))|(1<<(SqlParserHOUR-65))|(1<<(SqlParserIF-65))|(1<<(SqlParserINCLUDING-65))|(1<<(SqlParserINPUT-65))|(1<<(SqlParserINTEGER-65))|(1<<(SqlParserINTERVAL-65))|(1<<(SqlParserISOLATION-65))|(1<<(SqlParserLAST-65))|(1<<(SqlParserLATERAL-65))|(1<<(SqlParserLEVEL-65))|(1<<(SqlParserLIMIT-65)))) != 0) || (((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(SqlParserLOGICAL-97))|(1<<(SqlParserMAP-97))|(1<<(SqlParserMINUTE-97))|(1<<(SqlParserMONTH-97))|(1<<(SqlParserNFC-97))|(1<<(SqlParserNFD-97))|(1<<(SqlParserNFKC-97))|(1<<(SqlParserNFKD-97))|(1<<(SqlParserNO-97))|(1<<(SqlParserNULLIF-97))|(1<<(SqlParserNULLS-97))|(1<<(SqlParserONLY-97))|(1<<(SqlParserOPTION-97))|(1<<(SqlParserORDINALITY-97))|(1<<(SqlParserOUTPUT-97))|(1<<(SqlParserOVER-97))|(1<<(SqlParserPARTITION-97))|(1<<(SqlParserPARTITIONS-97))|(1<<(SqlParserPOSITION-97))|(1<<(SqlParserPRECEDING-97))|(1<<(SqlParserPRIVILEGES-97))|(1<<(SqlParserPROPERTIES-97))|(1<<(SqlParserPUBLIC-97)))) != 0) || (((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(SqlParserRANGE-129))|(1<<(SqlParserREAD-129))|(1<<(SqlParserRENAME-129))|(1<<(SqlParserREPEATABLE-129))|(1<<(SqlParserREPLACE-129))|(1<<(SqlParserRESET-129))|(1<<(SqlParserRESTRICT-129))|(1<<(SqlParserREVOKE-129))|(1<<(SqlParserROLLBACK-129))|(1<<(SqlParserROW-129))|(1<<(SqlParserROWS-129))|(1<<(SqlParserSCHEMA-129))|(1<<(SqlParserSCHEMAS-129))|(1<<(SqlParserSECOND-129))|(1<<(SqlParserSERIALIZABLE-129))|(1<<(SqlParserSESSION-129))|(1<<(SqlParserSET-129))|(1<<(SqlParserSETS-129))|(1<<(SqlParserSHOW-129))|(1<<(SqlParserSMALLINT-129))|(1<<(SqlParserSOME-129))|(1<<(SqlParserSTART-129))|(1<<(SqlParserSTATS-129))|(1<<(SqlParserSUBSTRING-129))|(1<<(SqlParserSYSTEM-129))|(1<<(SqlParserTABLES-129))|(1<<(SqlParserTABLESAMPLE-129)))) != 0) || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SqlParserTEXT-161))|(1<<(SqlParserTIME-161))|(1<<(SqlParserTIMESTAMP-161))|(1<<(SqlParserTINYINT-161))|(1<<(SqlParserTO-161))|(1<<(SqlParserTRANSACTION-161))|(1<<(SqlParserTRY_CAST-161))|(1<<(SqlParserTYPE-161))|(1<<(SqlParserUNBOUNDED-161))|(1<<(SqlParserUNCOMMITTED-161))|(1<<(SqlParserUSE-161))|(1<<(SqlParserVALIDATE-161))|(1<<(SqlParserVERBOSE-161))|(1<<(SqlParserVIEW-161))|(1<<(SqlParserWORK-161))|(1<<(SqlParserWRITE-161))|(1<<(SqlParserYEAR-161))|(1<<(SqlParserZONE-161)))) != 0) || (((_la-207)&-(0x1f+1)) == 0 && ((1<<uint((_la-207)))&((1<<(SqlParserIDENTIFIER-207))|(1<<(SqlParserDIGIT_IDENTIFIER-207))|(1<<(SqlParserQUOTED_IDENTIFIER-207))|(1<<(SqlParserBACKQUOTED_IDENTIFIER-207)))) != 0) {
			{
				p.SetState(768)
				p.QualifiedName()
			}
			p.SetState(773)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlParserT__0 {
				{
					p.SetState(769)
					p.Match(SqlParserT__0)
				}
				{
					p.SetState(770)
					p.QualifiedName()
				}

				p.SetState(775)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(778)
			p.Match(SqlParserT__2)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(791)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(789)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSubscriptContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*SubscriptContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlParserRULE_primaryExpression)
				p.SetState(781)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(782)
					p.Match(SqlParserT__6)
				}
				{
					p.SetState(783)

					var _x = p.valueExpression(0)

					localctx.(*SubscriptContext).index = _x
				}
				{
					p.SetState(784)
					p.Match(SqlParserT__7)
				}

			case 2:
				localctx = NewDereferenceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*DereferenceContext).base = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlParserRULE_primaryExpression)
				p.SetState(786)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(787)
					p.Match(SqlParserT__3)
				}
				{
					p.SetState(788)

					var _x = p.Identifier()

					localctx.(*DereferenceContext).fieldName = _x
				}

			}

		}
		p.SetState(793)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext())
	}

	return localctx
}

// IStringSqlContext is an interface to support dynamic dispatch.
type IStringSqlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringSqlContext differentiates from other interfaces.
	IsStringSqlContext()
}

type StringSqlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringSqlContext() *StringSqlContext {
	var p = new(StringSqlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_stringSql
	return p
}

func (*StringSqlContext) IsStringSqlContext() {}

func NewStringSqlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringSqlContext {
	var p = new(StringSqlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_stringSql

	return p
}

func (s *StringSqlContext) GetParser() antlr.Parser { return s.parser }

func (s *StringSqlContext) CopyFrom(ctx *StringSqlContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *StringSqlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringSqlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnicodeStringLiteralContext struct {
	*StringSqlContext
}

func NewUnicodeStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnicodeStringLiteralContext {
	var p = new(UnicodeStringLiteralContext)

	p.StringSqlContext = NewEmptyStringSqlContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StringSqlContext))

	return p
}

func (s *UnicodeStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnicodeStringLiteralContext) UNICODE_STRING() antlr.TerminalNode {
	return s.GetToken(SqlParserUNICODE_STRING, 0)
}

func (s *UnicodeStringLiteralContext) UESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlParserUESCAPE, 0)
}

func (s *UnicodeStringLiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(SqlParserSTRING, 0)
}

func (s *UnicodeStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterUnicodeStringLiteral(s)
	}
}

func (s *UnicodeStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitUnicodeStringLiteral(s)
	}
}

func (s *UnicodeStringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitUnicodeStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type BasicStringLiteralContext struct {
	*StringSqlContext
}

func NewBasicStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BasicStringLiteralContext {
	var p = new(BasicStringLiteralContext)

	p.StringSqlContext = NewEmptyStringSqlContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StringSqlContext))

	return p
}

func (s *BasicStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BasicStringLiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(SqlParserSTRING, 0)
}

func (s *BasicStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterBasicStringLiteral(s)
	}
}

func (s *BasicStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitBasicStringLiteral(s)
	}
}

func (s *BasicStringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitBasicStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) StringSql() (localctx IStringSqlContext) {
	localctx = NewStringSqlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SqlParserRULE_stringSql)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(800)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlParserSTRING:
		localctx = NewBasicStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(794)
			p.Match(SqlParserSTRING)
		}

	case SqlParserUNICODE_STRING:
		localctx = NewUnicodeStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(795)
			p.Match(SqlParserUNICODE_STRING)
		}
		p.SetState(798)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(796)
				p.Match(SqlParserUESCAPE)
			}
			{
				p.SetState(797)
				p.Match(SqlParserSTRING)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_comparisonOperator
	return p
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlParserEQ, 0)
}

func (s *ComparisonOperatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(SqlParserNEQ, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(SqlParserLT, 0)
}

func (s *ComparisonOperatorContext) LTE() antlr.TerminalNode {
	return s.GetToken(SqlParserLTE, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(SqlParserGT, 0)
}

func (s *ComparisonOperatorContext) GTE() antlr.TerminalNode {
	return s.GetToken(SqlParserGTE, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitComparisonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SqlParserRULE_comparisonOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(802)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-189)&-(0x1f+1)) == 0 && ((1<<uint((_la-189)))&((1<<(SqlParserEQ-189))|(1<<(SqlParserNEQ-189))|(1<<(SqlParserLT-189))|(1<<(SqlParserLTE-189))|(1<<(SqlParserGT-189))|(1<<(SqlParserGTE-189)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IComparisonQuantifierContext is an interface to support dynamic dispatch.
type IComparisonQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonQuantifierContext differentiates from other interfaces.
	IsComparisonQuantifierContext()
}

type ComparisonQuantifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonQuantifierContext() *ComparisonQuantifierContext {
	var p = new(ComparisonQuantifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_comparisonQuantifier
	return p
}

func (*ComparisonQuantifierContext) IsComparisonQuantifierContext() {}

func NewComparisonQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonQuantifierContext {
	var p = new(ComparisonQuantifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_comparisonQuantifier

	return p
}

func (s *ComparisonQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlParserALL, 0)
}

func (s *ComparisonQuantifierContext) SOME() antlr.TerminalNode {
	return s.GetToken(SqlParserSOME, 0)
}

func (s *ComparisonQuantifierContext) ANY() antlr.TerminalNode {
	return s.GetToken(SqlParserANY, 0)
}

func (s *ComparisonQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterComparisonQuantifier(s)
	}
}

func (s *ComparisonQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitComparisonQuantifier(s)
	}
}

func (s *ComparisonQuantifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitComparisonQuantifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) ComparisonQuantifier() (localctx IComparisonQuantifierContext) {
	localctx = NewComparisonQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SqlParserRULE_comparisonQuantifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(804)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlParserALL || _la == SqlParserANY || _la == SqlParserSOME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_booleanValue
	return p
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SqlParserTRUE, 0)
}

func (s *BooleanValueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(SqlParserFALSE, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (s *BooleanValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitBooleanValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SqlParserRULE_booleanValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(806)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlParserFALSE || _la == SqlParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITypeSqlContext is an interface to support dynamic dispatch.
type ITypeSqlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeSqlContext differentiates from other interfaces.
	IsTypeSqlContext()
}

type TypeSqlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSqlContext() *TypeSqlContext {
	var p = new(TypeSqlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_typeSql
	return p
}

func (*TypeSqlContext) IsTypeSqlContext() {}

func NewTypeSqlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSqlContext {
	var p = new(TypeSqlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_typeSql

	return p
}

func (s *TypeSqlContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSqlContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlParserARRAY, 0)
}

func (s *TypeSqlContext) AllTypeSql() []ITypeSqlContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeSqlContext)(nil)).Elem())
	var tst = make([]ITypeSqlContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeSqlContext)
		}
	}

	return tst
}

func (s *TypeSqlContext) TypeSql(i int) ITypeSqlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeSqlContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeSqlContext)
}

func (s *TypeSqlContext) MAP() antlr.TerminalNode {
	return s.GetToken(SqlParserMAP, 0)
}

func (s *TypeSqlContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlParserROW, 0)
}

func (s *TypeSqlContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *TypeSqlContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeSqlContext) BaseType() IBaseTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBaseTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBaseTypeContext)
}

func (s *TypeSqlContext) AllTypeParameter() []ITypeParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem())
	var tst = make([]ITypeParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeParameterContext)
		}
	}

	return tst
}

func (s *TypeSqlContext) TypeParameter(i int) ITypeParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *TypeSqlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSqlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeSqlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterTypeSql(s)
	}
}

func (s *TypeSqlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitTypeSql(s)
	}
}

func (s *TypeSqlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitTypeSql(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) TypeSql() (localctx ITypeSqlContext) {
	return p.typeSql(0)
}

func (p *SqlParser) typeSql(_p int) (localctx ITypeSqlContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewTypeSqlContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITypeSqlContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 76
	p.EnterRecursionRule(localctx, 76, SqlParserRULE_typeSql, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(850)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(809)
			p.Match(SqlParserARRAY)
		}
		{
			p.SetState(810)
			p.Match(SqlParserLT)
		}
		{
			p.SetState(811)
			p.typeSql(0)
		}
		{
			p.SetState(812)
			p.Match(SqlParserGT)
		}

	case 2:
		{
			p.SetState(814)
			p.Match(SqlParserMAP)
		}
		{
			p.SetState(815)
			p.Match(SqlParserLT)
		}
		{
			p.SetState(816)
			p.typeSql(0)
		}
		{
			p.SetState(817)
			p.Match(SqlParserT__0)
		}
		{
			p.SetState(818)
			p.typeSql(0)
		}
		{
			p.SetState(819)
			p.Match(SqlParserGT)
		}

	case 3:
		{
			p.SetState(821)
			p.Match(SqlParserROW)
		}
		{
			p.SetState(822)
			p.Match(SqlParserT__1)
		}
		{
			p.SetState(823)
			p.Identifier()
		}
		{
			p.SetState(824)
			p.typeSql(0)
		}
		p.SetState(831)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlParserT__0 {
			{
				p.SetState(825)
				p.Match(SqlParserT__0)
			}
			{
				p.SetState(826)
				p.Identifier()
			}
			{
				p.SetState(827)
				p.typeSql(0)
			}

			p.SetState(833)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(834)
			p.Match(SqlParserT__2)
		}

	case 4:
		{
			p.SetState(836)
			p.BaseType()
		}
		p.SetState(848)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(837)
				p.Match(SqlParserT__1)
			}
			{
				p.SetState(838)
				p.TypeParameter()
			}
			p.SetState(843)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlParserT__0 {
				{
					p.SetState(839)
					p.Match(SqlParserT__0)
				}
				{
					p.SetState(840)
					p.TypeParameter()
				}

				p.SetState(845)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(846)
				p.Match(SqlParserT__2)
			}

		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(856)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewTypeSqlContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, SqlParserRULE_typeSql)
			p.SetState(852)

			if !(p.Precpred(p.GetParserRuleContext(), 5)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
			}
			{
				p.SetState(853)
				p.Match(SqlParserARRAY)
			}

		}
		p.SetState(858)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_typeParameter
	return p
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlParserINTEGER_VALUE, 0)
}

func (s *TypeParameterContext) TypeSql() ITypeSqlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeSqlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeSqlContext)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (s *TypeParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitTypeParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SqlParserRULE_typeParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(861)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlParserINTEGER_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(859)
			p.Match(SqlParserINTEGER_VALUE)
		}

	case SqlParserADD, SqlParserALL, SqlParserANALYZE, SqlParserANY, SqlParserARRAY, SqlParserASC, SqlParserAT, SqlParserBERNOULLI, SqlParserCALL, SqlParserCASCADE, SqlParserCATALOGS, SqlParserCOALESCE, SqlParserCOLUMN, SqlParserCOLUMNS, SqlParserCOMMENT, SqlParserCOMMIT, SqlParserCOMMITTED, SqlParserCURRENT, SqlParserDATA, SqlParserDATE, SqlParserDAY, SqlParserDESC, SqlParserDISTRIBUTED, SqlParserEXCLUDING, SqlParserEXPLAIN, SqlParserFILTER, SqlParserFIRST, SqlParserFOLLOWING, SqlParserFORMAT, SqlParserFUNCTIONS, SqlParserGRANT, SqlParserGRANTS, SqlParserGRAPHVIZ, SqlParserHOUR, SqlParserIF, SqlParserINCLUDING, SqlParserINPUT, SqlParserINTEGER, SqlParserINTERVAL, SqlParserISOLATION, SqlParserLAST, SqlParserLATERAL, SqlParserLEVEL, SqlParserLIMIT, SqlParserLOGICAL, SqlParserMAP, SqlParserMINUTE, SqlParserMONTH, SqlParserNFC, SqlParserNFD, SqlParserNFKC, SqlParserNFKD, SqlParserNO, SqlParserNULLIF, SqlParserNULLS, SqlParserONLY, SqlParserOPTION, SqlParserORDINALITY, SqlParserOUTPUT, SqlParserOVER, SqlParserPARTITION, SqlParserPARTITIONS, SqlParserPOSITION, SqlParserPRECEDING, SqlParserPRIVILEGES, SqlParserPROPERTIES, SqlParserPUBLIC, SqlParserRANGE, SqlParserREAD, SqlParserRENAME, SqlParserREPEATABLE, SqlParserREPLACE, SqlParserRESET, SqlParserRESTRICT, SqlParserREVOKE, SqlParserROLLBACK, SqlParserROW, SqlParserROWS, SqlParserSCHEMA, SqlParserSCHEMAS, SqlParserSECOND, SqlParserSERIALIZABLE, SqlParserSESSION, SqlParserSET, SqlParserSETS, SqlParserSHOW, SqlParserSMALLINT, SqlParserSOME, SqlParserSTART, SqlParserSTATS, SqlParserSUBSTRING, SqlParserSYSTEM, SqlParserTABLES, SqlParserTABLESAMPLE, SqlParserTEXT, SqlParserTIME, SqlParserTIMESTAMP, SqlParserTINYINT, SqlParserTO, SqlParserTRANSACTION, SqlParserTRY_CAST, SqlParserTYPE, SqlParserUNBOUNDED, SqlParserUNCOMMITTED, SqlParserUSE, SqlParserVALIDATE, SqlParserVERBOSE, SqlParserVIEW, SqlParserWORK, SqlParserWRITE, SqlParserYEAR, SqlParserZONE, SqlParserIDENTIFIER, SqlParserDIGIT_IDENTIFIER, SqlParserQUOTED_IDENTIFIER, SqlParserBACKQUOTED_IDENTIFIER, SqlParserTIME_WITH_TIME_ZONE, SqlParserTIMESTAMP_WITH_TIME_ZONE, SqlParserDOUBLE_PRECISION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(860)
			p.typeSql(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBaseTypeContext is an interface to support dynamic dispatch.
type IBaseTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBaseTypeContext differentiates from other interfaces.
	IsBaseTypeContext()
}

type BaseTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseTypeContext() *BaseTypeContext {
	var p = new(BaseTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_baseType
	return p
}

func (*BaseTypeContext) IsBaseTypeContext() {}

func NewBaseTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTypeContext {
	var p = new(BaseTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_baseType

	return p
}

func (s *BaseTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTypeContext) TIME_WITH_TIME_ZONE() antlr.TerminalNode {
	return s.GetToken(SqlParserTIME_WITH_TIME_ZONE, 0)
}

func (s *BaseTypeContext) TIMESTAMP_WITH_TIME_ZONE() antlr.TerminalNode {
	return s.GetToken(SqlParserTIMESTAMP_WITH_TIME_ZONE, 0)
}

func (s *BaseTypeContext) DOUBLE_PRECISION() antlr.TerminalNode {
	return s.GetToken(SqlParserDOUBLE_PRECISION, 0)
}

func (s *BaseTypeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BaseTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterBaseType(s)
	}
}

func (s *BaseTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitBaseType(s)
	}
}

func (s *BaseTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitBaseType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) BaseType() (localctx IBaseTypeContext) {
	localctx = NewBaseTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SqlParserRULE_baseType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(867)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlParserTIME_WITH_TIME_ZONE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(863)
			p.Match(SqlParserTIME_WITH_TIME_ZONE)
		}

	case SqlParserTIMESTAMP_WITH_TIME_ZONE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(864)
			p.Match(SqlParserTIMESTAMP_WITH_TIME_ZONE)
		}

	case SqlParserDOUBLE_PRECISION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(865)
			p.Match(SqlParserDOUBLE_PRECISION)
		}

	case SqlParserADD, SqlParserALL, SqlParserANALYZE, SqlParserANY, SqlParserARRAY, SqlParserASC, SqlParserAT, SqlParserBERNOULLI, SqlParserCALL, SqlParserCASCADE, SqlParserCATALOGS, SqlParserCOALESCE, SqlParserCOLUMN, SqlParserCOLUMNS, SqlParserCOMMENT, SqlParserCOMMIT, SqlParserCOMMITTED, SqlParserCURRENT, SqlParserDATA, SqlParserDATE, SqlParserDAY, SqlParserDESC, SqlParserDISTRIBUTED, SqlParserEXCLUDING, SqlParserEXPLAIN, SqlParserFILTER, SqlParserFIRST, SqlParserFOLLOWING, SqlParserFORMAT, SqlParserFUNCTIONS, SqlParserGRANT, SqlParserGRANTS, SqlParserGRAPHVIZ, SqlParserHOUR, SqlParserIF, SqlParserINCLUDING, SqlParserINPUT, SqlParserINTEGER, SqlParserINTERVAL, SqlParserISOLATION, SqlParserLAST, SqlParserLATERAL, SqlParserLEVEL, SqlParserLIMIT, SqlParserLOGICAL, SqlParserMAP, SqlParserMINUTE, SqlParserMONTH, SqlParserNFC, SqlParserNFD, SqlParserNFKC, SqlParserNFKD, SqlParserNO, SqlParserNULLIF, SqlParserNULLS, SqlParserONLY, SqlParserOPTION, SqlParserORDINALITY, SqlParserOUTPUT, SqlParserOVER, SqlParserPARTITION, SqlParserPARTITIONS, SqlParserPOSITION, SqlParserPRECEDING, SqlParserPRIVILEGES, SqlParserPROPERTIES, SqlParserPUBLIC, SqlParserRANGE, SqlParserREAD, SqlParserRENAME, SqlParserREPEATABLE, SqlParserREPLACE, SqlParserRESET, SqlParserRESTRICT, SqlParserREVOKE, SqlParserROLLBACK, SqlParserROW, SqlParserROWS, SqlParserSCHEMA, SqlParserSCHEMAS, SqlParserSECOND, SqlParserSERIALIZABLE, SqlParserSESSION, SqlParserSET, SqlParserSETS, SqlParserSHOW, SqlParserSMALLINT, SqlParserSOME, SqlParserSTART, SqlParserSTATS, SqlParserSUBSTRING, SqlParserSYSTEM, SqlParserTABLES, SqlParserTABLESAMPLE, SqlParserTEXT, SqlParserTIME, SqlParserTIMESTAMP, SqlParserTINYINT, SqlParserTO, SqlParserTRANSACTION, SqlParserTRY_CAST, SqlParserTYPE, SqlParserUNBOUNDED, SqlParserUNCOMMITTED, SqlParserUSE, SqlParserVALIDATE, SqlParserVERBOSE, SqlParserVIEW, SqlParserWORK, SqlParserWRITE, SqlParserYEAR, SqlParserZONE, SqlParserIDENTIFIER, SqlParserDIGIT_IDENTIFIER, SqlParserQUOTED_IDENTIFIER, SqlParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(866)
			p.Identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_whenClause
	return p
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(SqlParserWHEN, 0)
}

func (s *WhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(SqlParserTHEN, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitWhenClause(s)
	}
}

func (s *WhenClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitWhenClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SqlParserRULE_whenClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(869)
		p.Match(SqlParserWHEN)
	}
	{
		p.SetState(870)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(871)
		p.Match(SqlParserTHEN)
	}
	{
		p.SetState(872)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).result = _x
	}

	return localctx
}

// IFilterContext is an interface to support dynamic dispatch.
type IFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFilterContext differentiates from other interfaces.
	IsFilterContext()
}

type FilterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterContext() *FilterContext {
	var p = new(FilterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_filter
	return p
}

func (*FilterContext) IsFilterContext() {}

func NewFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterContext {
	var p = new(FilterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_filter

	return p
}

func (s *FilterContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterContext) FILTER() antlr.TerminalNode {
	return s.GetToken(SqlParserFILTER, 0)
}

func (s *FilterContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlParserWHERE, 0)
}

func (s *FilterContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *FilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterFilter(s)
	}
}

func (s *FilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitFilter(s)
	}
}

func (s *FilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitFilter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) Filter() (localctx IFilterContext) {
	localctx = NewFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SqlParserRULE_filter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(874)
		p.Match(SqlParserFILTER)
	}
	{
		p.SetState(875)
		p.Match(SqlParserT__1)
	}
	{
		p.SetState(876)
		p.Match(SqlParserWHERE)
	}
	{
		p.SetState(877)
		p.booleanExpression(0)
	}
	{
		p.SetState(878)
		p.Match(SqlParserT__2)
	}

	return localctx
}

// IOverContext is an interface to support dynamic dispatch.
type IOverContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetPartition returns the partition rule context list.
	GetPartition() []IExpressionContext

	// SetPartition sets the partition rule context list.
	SetPartition([]IExpressionContext)

	// IsOverContext differentiates from other interfaces.
	IsOverContext()
}

type OverContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	_expression IExpressionContext
	partition   []IExpressionContext
}

func NewEmptyOverContext() *OverContext {
	var p = new(OverContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_over
	return p
}

func (*OverContext) IsOverContext() {}

func NewOverContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverContext {
	var p = new(OverContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_over

	return p
}

func (s *OverContext) GetParser() antlr.Parser { return s.parser }

func (s *OverContext) Get_expression() IExpressionContext { return s._expression }

func (s *OverContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *OverContext) GetPartition() []IExpressionContext { return s.partition }

func (s *OverContext) SetPartition(v []IExpressionContext) { s.partition = v }

func (s *OverContext) OVER() antlr.TerminalNode {
	return s.GetToken(SqlParserOVER, 0)
}

func (s *OverContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SqlParserPARTITION, 0)
}

func (s *OverContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(SqlParserBY)
}

func (s *OverContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(SqlParserBY, i)
}

func (s *OverContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SqlParserORDER, 0)
}

func (s *OverContext) AllSortItem() []ISortItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortItemContext)(nil)).Elem())
	var tst = make([]ISortItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortItemContext)
		}
	}

	return tst
}

func (s *OverContext) SortItem(i int) ISortItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *OverContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *OverContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OverContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterOver(s)
	}
}

func (s *OverContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitOver(s)
	}
}

func (s *OverContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitOver(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) Over() (localctx IOverContext) {
	localctx = NewOverContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SqlParserRULE_over)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(880)
		p.Match(SqlParserOVER)
	}
	{
		p.SetState(881)
		p.Match(SqlParserT__1)
	}
	p.SetState(892)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlParserPARTITION {
		{
			p.SetState(882)
			p.Match(SqlParserPARTITION)
		}
		{
			p.SetState(883)
			p.Match(SqlParserBY)
		}
		{
			p.SetState(884)

			var _x = p.Expression()

			localctx.(*OverContext)._expression = _x
		}
		localctx.(*OverContext).partition = append(localctx.(*OverContext).partition, localctx.(*OverContext)._expression)
		p.SetState(889)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlParserT__0 {
			{
				p.SetState(885)
				p.Match(SqlParserT__0)
			}
			{
				p.SetState(886)

				var _x = p.Expression()

				localctx.(*OverContext)._expression = _x
			}
			localctx.(*OverContext).partition = append(localctx.(*OverContext).partition, localctx.(*OverContext)._expression)

			p.SetState(891)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(904)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlParserORDER {
		{
			p.SetState(894)
			p.Match(SqlParserORDER)
		}
		{
			p.SetState(895)
			p.Match(SqlParserBY)
		}
		{
			p.SetState(896)
			p.SortItem()
		}
		p.SetState(901)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlParserT__0 {
			{
				p.SetState(897)
				p.Match(SqlParserT__0)
			}
			{
				p.SetState(898)
				p.SortItem()
			}

			p.SetState(903)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(906)
		p.Match(SqlParserT__2)
	}

	return localctx
}

// IPrivilegeContext is an interface to support dynamic dispatch.
type IPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrivilegeContext differentiates from other interfaces.
	IsPrivilegeContext()
}

type PrivilegeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeContext() *PrivilegeContext {
	var p = new(PrivilegeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_privilege
	return p
}

func (*PrivilegeContext) IsPrivilegeContext() {}

func NewPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeContext {
	var p = new(PrivilegeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_privilege

	return p
}

func (s *PrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SqlParserSELECT, 0)
}

func (s *PrivilegeContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SqlParserDELETE, 0)
}

func (s *PrivilegeContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SqlParserINSERT, 0)
}

func (s *PrivilegeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterPrivilege(s)
	}
}

func (s *PrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitPrivilege(s)
	}
}

func (s *PrivilegeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitPrivilege(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) Privilege() (localctx IPrivilegeContext) {
	localctx = NewPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SqlParserRULE_privilege)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(912)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlParserSELECT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(908)
			p.Match(SqlParserSELECT)
		}

	case SqlParserDELETE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(909)
			p.Match(SqlParserDELETE)
		}

	case SqlParserINSERT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(910)
			p.Match(SqlParserINSERT)
		}

	case SqlParserADD, SqlParserALL, SqlParserANALYZE, SqlParserANY, SqlParserARRAY, SqlParserASC, SqlParserAT, SqlParserBERNOULLI, SqlParserCALL, SqlParserCASCADE, SqlParserCATALOGS, SqlParserCOALESCE, SqlParserCOLUMN, SqlParserCOLUMNS, SqlParserCOMMENT, SqlParserCOMMIT, SqlParserCOMMITTED, SqlParserCURRENT, SqlParserDATA, SqlParserDATE, SqlParserDAY, SqlParserDESC, SqlParserDISTRIBUTED, SqlParserEXCLUDING, SqlParserEXPLAIN, SqlParserFILTER, SqlParserFIRST, SqlParserFOLLOWING, SqlParserFORMAT, SqlParserFUNCTIONS, SqlParserGRANT, SqlParserGRANTS, SqlParserGRAPHVIZ, SqlParserHOUR, SqlParserIF, SqlParserINCLUDING, SqlParserINPUT, SqlParserINTEGER, SqlParserINTERVAL, SqlParserISOLATION, SqlParserLAST, SqlParserLATERAL, SqlParserLEVEL, SqlParserLIMIT, SqlParserLOGICAL, SqlParserMAP, SqlParserMINUTE, SqlParserMONTH, SqlParserNFC, SqlParserNFD, SqlParserNFKC, SqlParserNFKD, SqlParserNO, SqlParserNULLIF, SqlParserNULLS, SqlParserONLY, SqlParserOPTION, SqlParserORDINALITY, SqlParserOUTPUT, SqlParserOVER, SqlParserPARTITION, SqlParserPARTITIONS, SqlParserPOSITION, SqlParserPRECEDING, SqlParserPRIVILEGES, SqlParserPROPERTIES, SqlParserPUBLIC, SqlParserRANGE, SqlParserREAD, SqlParserRENAME, SqlParserREPEATABLE, SqlParserREPLACE, SqlParserRESET, SqlParserRESTRICT, SqlParserREVOKE, SqlParserROLLBACK, SqlParserROW, SqlParserROWS, SqlParserSCHEMA, SqlParserSCHEMAS, SqlParserSECOND, SqlParserSERIALIZABLE, SqlParserSESSION, SqlParserSET, SqlParserSETS, SqlParserSHOW, SqlParserSMALLINT, SqlParserSOME, SqlParserSTART, SqlParserSTATS, SqlParserSUBSTRING, SqlParserSYSTEM, SqlParserTABLES, SqlParserTABLESAMPLE, SqlParserTEXT, SqlParserTIME, SqlParserTIMESTAMP, SqlParserTINYINT, SqlParserTO, SqlParserTRANSACTION, SqlParserTRY_CAST, SqlParserTYPE, SqlParserUNBOUNDED, SqlParserUNCOMMITTED, SqlParserUSE, SqlParserVALIDATE, SqlParserVERBOSE, SqlParserVIEW, SqlParserWORK, SqlParserWRITE, SqlParserYEAR, SqlParserZONE, SqlParserIDENTIFIER, SqlParserDIGIT_IDENTIFIER, SqlParserQUOTED_IDENTIFIER, SqlParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(911)
			p.Identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_qualifiedName
	return p
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *QualifiedNameContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterQualifiedName(s)
	}
}

func (s *QualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitQualifiedName(s)
	}
}

func (s *QualifiedNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitQualifiedName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SqlParserRULE_qualifiedName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(914)
		p.Identifier()
	}
	p.SetState(919)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(915)
				p.Match(SqlParserT__3)
			}
			{
				p.SetState(916)
				p.Identifier()
			}

		}
		p.SetState(921)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext())
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) CopyFrom(ctx *IdentifierContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BackQuotedIdentifierContext struct {
	*IdentifierContext
}

func NewBackQuotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BackQuotedIdentifierContext {
	var p = new(BackQuotedIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *BackQuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackQuotedIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *BackQuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitBackQuotedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type QuotedIdentifierContext struct {
	*IdentifierContext
}

func NewQuotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuotedIdentifierContext {
	var p = new(QuotedIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *QuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierContext) QUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlParserQUOTED_IDENTIFIER, 0)
}

func (s *QuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterQuotedIdentifier(s)
	}
}

func (s *QuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitQuotedIdentifier(s)
	}
}

func (s *QuotedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitQuotedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type DigitIdentifierContext struct {
	*IdentifierContext
}

func NewDigitIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DigitIdentifierContext {
	var p = new(DigitIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *DigitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitIdentifierContext) DIGIT_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlParserDIGIT_IDENTIFIER, 0)
}

func (s *DigitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitDigitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnquotedIdentifierContext struct {
	*IdentifierContext
}

func NewUnquotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *UnquotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlParserIDENTIFIER, 0)
}

func (s *UnquotedIdentifierContext) NonReserved() INonReservedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonReservedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *UnquotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitUnquotedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SqlParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(927)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlParserIDENTIFIER:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(922)
			p.Match(SqlParserIDENTIFIER)
		}

	case SqlParserQUOTED_IDENTIFIER:
		localctx = NewQuotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(923)
			p.Match(SqlParserQUOTED_IDENTIFIER)
		}

	case SqlParserADD, SqlParserALL, SqlParserANALYZE, SqlParserANY, SqlParserARRAY, SqlParserASC, SqlParserAT, SqlParserBERNOULLI, SqlParserCALL, SqlParserCASCADE, SqlParserCATALOGS, SqlParserCOALESCE, SqlParserCOLUMN, SqlParserCOLUMNS, SqlParserCOMMENT, SqlParserCOMMIT, SqlParserCOMMITTED, SqlParserCURRENT, SqlParserDATA, SqlParserDATE, SqlParserDAY, SqlParserDESC, SqlParserDISTRIBUTED, SqlParserEXCLUDING, SqlParserEXPLAIN, SqlParserFILTER, SqlParserFIRST, SqlParserFOLLOWING, SqlParserFORMAT, SqlParserFUNCTIONS, SqlParserGRANT, SqlParserGRANTS, SqlParserGRAPHVIZ, SqlParserHOUR, SqlParserIF, SqlParserINCLUDING, SqlParserINPUT, SqlParserINTEGER, SqlParserINTERVAL, SqlParserISOLATION, SqlParserLAST, SqlParserLATERAL, SqlParserLEVEL, SqlParserLIMIT, SqlParserLOGICAL, SqlParserMAP, SqlParserMINUTE, SqlParserMONTH, SqlParserNFC, SqlParserNFD, SqlParserNFKC, SqlParserNFKD, SqlParserNO, SqlParserNULLIF, SqlParserNULLS, SqlParserONLY, SqlParserOPTION, SqlParserORDINALITY, SqlParserOUTPUT, SqlParserOVER, SqlParserPARTITION, SqlParserPARTITIONS, SqlParserPOSITION, SqlParserPRECEDING, SqlParserPRIVILEGES, SqlParserPROPERTIES, SqlParserPUBLIC, SqlParserRANGE, SqlParserREAD, SqlParserRENAME, SqlParserREPEATABLE, SqlParserREPLACE, SqlParserRESET, SqlParserRESTRICT, SqlParserREVOKE, SqlParserROLLBACK, SqlParserROW, SqlParserROWS, SqlParserSCHEMA, SqlParserSCHEMAS, SqlParserSECOND, SqlParserSERIALIZABLE, SqlParserSESSION, SqlParserSET, SqlParserSETS, SqlParserSHOW, SqlParserSMALLINT, SqlParserSOME, SqlParserSTART, SqlParserSTATS, SqlParserSUBSTRING, SqlParserSYSTEM, SqlParserTABLES, SqlParserTABLESAMPLE, SqlParserTEXT, SqlParserTIME, SqlParserTIMESTAMP, SqlParserTINYINT, SqlParserTO, SqlParserTRANSACTION, SqlParserTRY_CAST, SqlParserTYPE, SqlParserUNBOUNDED, SqlParserUNCOMMITTED, SqlParserUSE, SqlParserVALIDATE, SqlParserVERBOSE, SqlParserVIEW, SqlParserWORK, SqlParserWRITE, SqlParserYEAR, SqlParserZONE:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(924)
			p.NonReserved()
		}

	case SqlParserBACKQUOTED_IDENTIFIER:
		localctx = NewBackQuotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(925)
			p.Match(SqlParserBACKQUOTED_IDENTIFIER)
		}

	case SqlParserDIGIT_IDENTIFIER:
		localctx = NewDigitIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(926)
			p.Match(SqlParserDIGIT_IDENTIFIER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_number
	return p
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) CopyFrom(ctx *NumberContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DecimalLiteralContext struct {
	*NumberContext
}

func NewDecimalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	p.NumberContext = NewEmptyNumberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*NumberContext))

	return p
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlParserDECIMAL_VALUE, 0)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitDecimalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type DoubleLiteralContext struct {
	*NumberContext
}

func NewDoubleLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoubleLiteralContext {
	var p = new(DoubleLiteralContext)

	p.NumberContext = NewEmptyNumberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*NumberContext))

	return p
}

func (s *DoubleLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleLiteralContext) DOUBLE_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlParserDOUBLE_VALUE, 0)
}

func (s *DoubleLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterDoubleLiteral(s)
	}
}

func (s *DoubleLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitDoubleLiteral(s)
	}
}

func (s *DoubleLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitDoubleLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntegerLiteralContext struct {
	*NumberContext
}

func NewIntegerLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	p.NumberContext = NewEmptyNumberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*NumberContext))

	return p
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlParserINTEGER_VALUE, 0)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitIntegerLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SqlParserRULE_number)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(932)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlParserDECIMAL_VALUE:
		localctx = NewDecimalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(929)
			p.Match(SqlParserDECIMAL_VALUE)
		}

	case SqlParserDOUBLE_VALUE:
		localctx = NewDoubleLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(930)
			p.Match(SqlParserDOUBLE_VALUE)
		}

	case SqlParserINTEGER_VALUE:
		localctx = NewIntegerLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(931)
			p.Match(SqlParserINTEGER_VALUE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlParserRULE_nonReserved
	return p
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) ADD() antlr.TerminalNode {
	return s.GetToken(SqlParserADD, 0)
}

func (s *NonReservedContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlParserALL, 0)
}

func (s *NonReservedContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(SqlParserANALYZE, 0)
}

func (s *NonReservedContext) ANY() antlr.TerminalNode {
	return s.GetToken(SqlParserANY, 0)
}

func (s *NonReservedContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlParserARRAY, 0)
}

func (s *NonReservedContext) ASC() antlr.TerminalNode {
	return s.GetToken(SqlParserASC, 0)
}

func (s *NonReservedContext) AT() antlr.TerminalNode {
	return s.GetToken(SqlParserAT, 0)
}

func (s *NonReservedContext) BERNOULLI() antlr.TerminalNode {
	return s.GetToken(SqlParserBERNOULLI, 0)
}

func (s *NonReservedContext) CALL() antlr.TerminalNode {
	return s.GetToken(SqlParserCALL, 0)
}

func (s *NonReservedContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SqlParserCASCADE, 0)
}

func (s *NonReservedContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(SqlParserCATALOGS, 0)
}

func (s *NonReservedContext) COALESCE() antlr.TerminalNode {
	return s.GetToken(SqlParserCOALESCE, 0)
}

func (s *NonReservedContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlParserCOLUMN, 0)
}

func (s *NonReservedContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SqlParserCOLUMNS, 0)
}

func (s *NonReservedContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlParserCOMMENT, 0)
}

func (s *NonReservedContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(SqlParserCOMMIT, 0)
}

func (s *NonReservedContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(SqlParserCOMMITTED, 0)
}

func (s *NonReservedContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SqlParserCURRENT, 0)
}

func (s *NonReservedContext) DATA() antlr.TerminalNode {
	return s.GetToken(SqlParserDATA, 0)
}

func (s *NonReservedContext) DATE() antlr.TerminalNode {
	return s.GetToken(SqlParserDATE, 0)
}

func (s *NonReservedContext) DAY() antlr.TerminalNode {
	return s.GetToken(SqlParserDAY, 0)
}

func (s *NonReservedContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlParserDESC, 0)
}

func (s *NonReservedContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(SqlParserDISTRIBUTED, 0)
}

func (s *NonReservedContext) EXCLUDING() antlr.TerminalNode {
	return s.GetToken(SqlParserEXCLUDING, 0)
}

func (s *NonReservedContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(SqlParserEXPLAIN, 0)
}

func (s *NonReservedContext) FILTER() antlr.TerminalNode {
	return s.GetToken(SqlParserFILTER, 0)
}

func (s *NonReservedContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SqlParserFIRST, 0)
}

func (s *NonReservedContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SqlParserFOLLOWING, 0)
}

func (s *NonReservedContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(SqlParserFORMAT, 0)
}

func (s *NonReservedContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(SqlParserFUNCTIONS, 0)
}

func (s *NonReservedContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SqlParserGRANT, 0)
}

func (s *NonReservedContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(SqlParserGRANTS, 0)
}

func (s *NonReservedContext) GRAPHVIZ() antlr.TerminalNode {
	return s.GetToken(SqlParserGRAPHVIZ, 0)
}

func (s *NonReservedContext) HOUR() antlr.TerminalNode {
	return s.GetToken(SqlParserHOUR, 0)
}

func (s *NonReservedContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlParserIF, 0)
}

func (s *NonReservedContext) INCLUDING() antlr.TerminalNode {
	return s.GetToken(SqlParserINCLUDING, 0)
}

func (s *NonReservedContext) INPUT() antlr.TerminalNode {
	return s.GetToken(SqlParserINPUT, 0)
}

func (s *NonReservedContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(SqlParserINTEGER, 0)
}

func (s *NonReservedContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SqlParserINTERVAL, 0)
}

func (s *NonReservedContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(SqlParserISOLATION, 0)
}

func (s *NonReservedContext) LAST() antlr.TerminalNode {
	return s.GetToken(SqlParserLAST, 0)
}

func (s *NonReservedContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(SqlParserLATERAL, 0)
}

func (s *NonReservedContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(SqlParserLEVEL, 0)
}

func (s *NonReservedContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SqlParserLIMIT, 0)
}

func (s *NonReservedContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(SqlParserLOGICAL, 0)
}

func (s *NonReservedContext) MAP() antlr.TerminalNode {
	return s.GetToken(SqlParserMAP, 0)
}

func (s *NonReservedContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(SqlParserMINUTE, 0)
}

func (s *NonReservedContext) MONTH() antlr.TerminalNode {
	return s.GetToken(SqlParserMONTH, 0)
}

func (s *NonReservedContext) NFC() antlr.TerminalNode {
	return s.GetToken(SqlParserNFC, 0)
}

func (s *NonReservedContext) NFD() antlr.TerminalNode {
	return s.GetToken(SqlParserNFD, 0)
}

func (s *NonReservedContext) NFKC() antlr.TerminalNode {
	return s.GetToken(SqlParserNFKC, 0)
}

func (s *NonReservedContext) NFKD() antlr.TerminalNode {
	return s.GetToken(SqlParserNFKD, 0)
}

func (s *NonReservedContext) NO() antlr.TerminalNode {
	return s.GetToken(SqlParserNO, 0)
}

func (s *NonReservedContext) NULLIF() antlr.TerminalNode {
	return s.GetToken(SqlParserNULLIF, 0)
}

func (s *NonReservedContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SqlParserNULLS, 0)
}

func (s *NonReservedContext) ONLY() antlr.TerminalNode {
	return s.GetToken(SqlParserONLY, 0)
}

func (s *NonReservedContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SqlParserOPTION, 0)
}

func (s *NonReservedContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(SqlParserORDINALITY, 0)
}

func (s *NonReservedContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(SqlParserOUTPUT, 0)
}

func (s *NonReservedContext) OVER() antlr.TerminalNode {
	return s.GetToken(SqlParserOVER, 0)
}

func (s *NonReservedContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SqlParserPARTITION, 0)
}

func (s *NonReservedContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(SqlParserPARTITIONS, 0)
}

func (s *NonReservedContext) POSITION() antlr.TerminalNode {
	return s.GetToken(SqlParserPOSITION, 0)
}

func (s *NonReservedContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SqlParserPRECEDING, 0)
}

func (s *NonReservedContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(SqlParserPRIVILEGES, 0)
}

func (s *NonReservedContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlParserPROPERTIES, 0)
}

func (s *NonReservedContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(SqlParserPUBLIC, 0)
}

func (s *NonReservedContext) RANGE() antlr.TerminalNode {
	return s.GetToken(SqlParserRANGE, 0)
}

func (s *NonReservedContext) READ() antlr.TerminalNode {
	return s.GetToken(SqlParserREAD, 0)
}

func (s *NonReservedContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SqlParserRENAME, 0)
}

func (s *NonReservedContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(SqlParserREPEATABLE, 0)
}

func (s *NonReservedContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlParserREPLACE, 0)
}

func (s *NonReservedContext) RESET() antlr.TerminalNode {
	return s.GetToken(SqlParserRESET, 0)
}

func (s *NonReservedContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(SqlParserRESTRICT, 0)
}

func (s *NonReservedContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(SqlParserREVOKE, 0)
}

func (s *NonReservedContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(SqlParserROLLBACK, 0)
}

func (s *NonReservedContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlParserROW, 0)
}

func (s *NonReservedContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SqlParserROWS, 0)
}

func (s *NonReservedContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SqlParserSCHEMA, 0)
}

func (s *NonReservedContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(SqlParserSCHEMAS, 0)
}

func (s *NonReservedContext) SECOND() antlr.TerminalNode {
	return s.GetToken(SqlParserSECOND, 0)
}

func (s *NonReservedContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(SqlParserSERIALIZABLE, 0)
}

func (s *NonReservedContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SqlParserSESSION, 0)
}

func (s *NonReservedContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlParserSET, 0)
}

func (s *NonReservedContext) SETS() antlr.TerminalNode {
	return s.GetToken(SqlParserSETS, 0)
}

func (s *NonReservedContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlParserSHOW, 0)
}

func (s *NonReservedContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(SqlParserSMALLINT, 0)
}

func (s *NonReservedContext) SOME() antlr.TerminalNode {
	return s.GetToken(SqlParserSOME, 0)
}

func (s *NonReservedContext) START() antlr.TerminalNode {
	return s.GetToken(SqlParserSTART, 0)
}

func (s *NonReservedContext) STATS() antlr.TerminalNode {
	return s.GetToken(SqlParserSTATS, 0)
}

func (s *NonReservedContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(SqlParserSUBSTRING, 0)
}

func (s *NonReservedContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(SqlParserSYSTEM, 0)
}

func (s *NonReservedContext) TABLES() antlr.TerminalNode {
	return s.GetToken(SqlParserTABLES, 0)
}

func (s *NonReservedContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(SqlParserTABLESAMPLE, 0)
}

func (s *NonReservedContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SqlParserTEXT, 0)
}

func (s *NonReservedContext) TIME() antlr.TerminalNode {
	return s.GetToken(SqlParserTIME, 0)
}

func (s *NonReservedContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlParserTIMESTAMP, 0)
}

func (s *NonReservedContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(SqlParserTINYINT, 0)
}

func (s *NonReservedContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlParserTO, 0)
}

func (s *NonReservedContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SqlParserTRANSACTION, 0)
}

func (s *NonReservedContext) TRY_CAST() antlr.TerminalNode {
	return s.GetToken(SqlParserTRY_CAST, 0)
}

func (s *NonReservedContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SqlParserTYPE, 0)
}

func (s *NonReservedContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(SqlParserUNBOUNDED, 0)
}

func (s *NonReservedContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(SqlParserUNCOMMITTED, 0)
}

func (s *NonReservedContext) USE() antlr.TerminalNode {
	return s.GetToken(SqlParserUSE, 0)
}

func (s *NonReservedContext) VALIDATE() antlr.TerminalNode {
	return s.GetToken(SqlParserVALIDATE, 0)
}

func (s *NonReservedContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(SqlParserVERBOSE, 0)
}

func (s *NonReservedContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlParserVIEW, 0)
}

func (s *NonReservedContext) WORK() antlr.TerminalNode {
	return s.GetToken(SqlParserWORK, 0)
}

func (s *NonReservedContext) WRITE() antlr.TerminalNode {
	return s.GetToken(SqlParserWRITE, 0)
}

func (s *NonReservedContext) YEAR() antlr.TerminalNode {
	return s.GetToken(SqlParserYEAR, 0)
}

func (s *NonReservedContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SqlParserZONE, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.EnterNonReserved(s)
	}
}

func (s *NonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlListener); ok {
		listenerT.ExitNonReserved(s)
	}
}

func (s *NonReservedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlVisitor:
		return t.VisitNonReserved(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlParser) NonReserved() (localctx INonReservedContext) {
	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SqlParserRULE_nonReserved)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(934)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlParserADD)|(1<<SqlParserALL)|(1<<SqlParserANALYZE)|(1<<SqlParserANY)|(1<<SqlParserARRAY)|(1<<SqlParserASC)|(1<<SqlParserAT)|(1<<SqlParserBERNOULLI)|(1<<SqlParserCALL)|(1<<SqlParserCASCADE)|(1<<SqlParserCATALOGS)|(1<<SqlParserCOALESCE)|(1<<SqlParserCOLUMN)|(1<<SqlParserCOLUMNS)|(1<<SqlParserCOMMENT)|(1<<SqlParserCOMMIT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlParserCOMMITTED-32))|(1<<(SqlParserCURRENT-32))|(1<<(SqlParserDATA-32))|(1<<(SqlParserDATE-32))|(1<<(SqlParserDAY-32))|(1<<(SqlParserDESC-32))|(1<<(SqlParserDISTRIBUTED-32))|(1<<(SqlParserEXCLUDING-32))|(1<<(SqlParserEXPLAIN-32))|(1<<(SqlParserFILTER-32))|(1<<(SqlParserFIRST-32))|(1<<(SqlParserFOLLOWING-32)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(SqlParserFORMAT-65))|(1<<(SqlParserFUNCTIONS-65))|(1<<(SqlParserGRANT-65))|(1<<(SqlParserGRANTS-65))|(1<<(SqlParserGRAPHVIZ-65))|(1<<(SqlParserHOUR-65))|(1<<(SqlParserIF-65))|(1<<(SqlParserINCLUDING-65))|(1<<(SqlParserINPUT-65))|(1<<(SqlParserINTEGER-65))|(1<<(SqlParserINTERVAL-65))|(1<<(SqlParserISOLATION-65))|(1<<(SqlParserLAST-65))|(1<<(SqlParserLATERAL-65))|(1<<(SqlParserLEVEL-65))|(1<<(SqlParserLIMIT-65)))) != 0) || (((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(SqlParserLOGICAL-97))|(1<<(SqlParserMAP-97))|(1<<(SqlParserMINUTE-97))|(1<<(SqlParserMONTH-97))|(1<<(SqlParserNFC-97))|(1<<(SqlParserNFD-97))|(1<<(SqlParserNFKC-97))|(1<<(SqlParserNFKD-97))|(1<<(SqlParserNO-97))|(1<<(SqlParserNULLIF-97))|(1<<(SqlParserNULLS-97))|(1<<(SqlParserONLY-97))|(1<<(SqlParserOPTION-97))|(1<<(SqlParserORDINALITY-97))|(1<<(SqlParserOUTPUT-97))|(1<<(SqlParserOVER-97))|(1<<(SqlParserPARTITION-97))|(1<<(SqlParserPARTITIONS-97))|(1<<(SqlParserPOSITION-97))|(1<<(SqlParserPRECEDING-97))|(1<<(SqlParserPRIVILEGES-97))|(1<<(SqlParserPROPERTIES-97))|(1<<(SqlParserPUBLIC-97)))) != 0) || (((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(SqlParserRANGE-129))|(1<<(SqlParserREAD-129))|(1<<(SqlParserRENAME-129))|(1<<(SqlParserREPEATABLE-129))|(1<<(SqlParserREPLACE-129))|(1<<(SqlParserRESET-129))|(1<<(SqlParserRESTRICT-129))|(1<<(SqlParserREVOKE-129))|(1<<(SqlParserROLLBACK-129))|(1<<(SqlParserROW-129))|(1<<(SqlParserROWS-129))|(1<<(SqlParserSCHEMA-129))|(1<<(SqlParserSCHEMAS-129))|(1<<(SqlParserSECOND-129))|(1<<(SqlParserSERIALIZABLE-129))|(1<<(SqlParserSESSION-129))|(1<<(SqlParserSET-129))|(1<<(SqlParserSETS-129))|(1<<(SqlParserSHOW-129))|(1<<(SqlParserSMALLINT-129))|(1<<(SqlParserSOME-129))|(1<<(SqlParserSTART-129))|(1<<(SqlParserSTATS-129))|(1<<(SqlParserSUBSTRING-129))|(1<<(SqlParserSYSTEM-129))|(1<<(SqlParserTABLES-129))|(1<<(SqlParserTABLESAMPLE-129)))) != 0) || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SqlParserTEXT-161))|(1<<(SqlParserTIME-161))|(1<<(SqlParserTIMESTAMP-161))|(1<<(SqlParserTINYINT-161))|(1<<(SqlParserTO-161))|(1<<(SqlParserTRANSACTION-161))|(1<<(SqlParserTRY_CAST-161))|(1<<(SqlParserTYPE-161))|(1<<(SqlParserUNBOUNDED-161))|(1<<(SqlParserUNCOMMITTED-161))|(1<<(SqlParserUSE-161))|(1<<(SqlParserVALIDATE-161))|(1<<(SqlParserVERBOSE-161))|(1<<(SqlParserVIEW-161))|(1<<(SqlParserWORK-161))|(1<<(SqlParserWRITE-161))|(1<<(SqlParserYEAR-161))|(1<<(SqlParserZONE-161)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *SqlParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 10:
		var t *QueryTermContext = nil
		if localctx != nil {
			t = localctx.(*QueryTermContext)
		}
		return p.QueryTerm_Sempred(t, predIndex)

	case 20:
		var t *RelationContext = nil
		if localctx != nil {
			t = localctx.(*RelationContext)
		}
		return p.Relation_Sempred(t, predIndex)

	case 29:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 32:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 33:
		var t *PrimaryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExpressionContext)
		}
		return p.PrimaryExpression_Sempred(t, predIndex)

	case 38:
		var t *TypeSqlContext = nil
		if localctx != nil {
			t = localctx.(*TypeSqlContext)
		}
		return p.TypeSql_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SqlParser) QueryTerm_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlParser) Relation_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlParser) PrimaryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 10)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlParser) TypeSql_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return p.Precpred(p.GetParserRuleContext(), 5)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
